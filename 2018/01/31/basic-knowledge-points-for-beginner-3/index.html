<!DOCTYPE html><html lang="zh-cmn-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>由重构进阶前端开发入门 (四) 面向对象 · 亦知亦解</title><meta name="description" content="由重构进阶前端开发入门 (四) 面向对象 - krimeshu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/gandalfr.css"><link rel="stylesheet" href="https://highlightjs.org/static/demo/styles/solarized-light.css"><link rel="search" type="application/opensearchdescription+xml" href="http://blog.krimeshu.com/atom.xml" title="亦知亦解"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/icon-tech.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="//github.com/krimeshu" target="_self" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">由重构进阶前端开发入门 (四) 面向对象</h1><div class="tags"><a href="/tags/前端/" class="tag-title">#前端</a><a href="/tags/初学者/" class="tag-title">#初学者</a><a href="/tags/面向对象/" class="tag-title">#面向对象</a></div><div class="post-info">Jan 31, 2018</div><aside id="toc" class="toc-wrap"><h3 class="toc-title">目录</h3><div class="toc-tree"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#四-面向对象"><span class="toc-text">(四) 面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DRY-Don’t-Repeat-Yourself-原则"><span class="toc-text">DRY (Don’t Repeat Yourself) 原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数复用、公用库"><span class="toc-text">函数复用、公用库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#对话框展示函数"><span class="toc-text">对话框展示函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#抽象成对象-类"><span class="toc-text">抽象成对象/类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#对话框类的定义"><span class="toc-text">对话框类的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对话框实例"><span class="toc-text">对话框实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li></ol></li></ol></li></ol></div></aside><style type="text/css">.toc-wrap {
    float: right;
    padding: 10px 30px 20px 24px;
    margin-bottom: 10px;
    background: #f2f8f2;
}
.toc-title::before {
    content: '#';
    color: #42b983
}
.toc, .toc-child {
    list-style: none;
    padding-left: 20px;
}</style><div class="post-content"><p>了解了在浏览器环境下，使用 JS 编程的基础概念之后，开始思考如何组织优化自己的代码，从编程技巧上提升开发和维护工作的效率吧。</p>
<a id="more"></a>
<blockquote>
<p>相关文章：</p>
<a href="/2017/05/04/basic-knowledge-points-for-beginner/" title="由重构进阶前端开发入门 (一) DOM 操作">由重构进阶前端开发入门 (一) DOM 操作</a>
<a href="/2017/08/24/basic-knowledge-points-for-beginner-1/" title="由重构进阶前端开发入门 (二) 事件与事件对象">由重构进阶前端开发入门 (二) 事件与事件对象</a>
<a href="/2017/10/25/basic-knowledge-points-for-beginner-2/" title="由重构进阶前端开发入门 (三) 事件冒泡与事件代理">由重构进阶前端开发入门 (三) 事件冒泡与事件代理</a>
</blockquote>
<h1 id="四-面向对象"><a href="#四-面向对象" class="headerlink" title="(四) 面向对象"></a>(四) 面向对象</h1><h2 id="DRY-Don’t-Repeat-Yourself-原则"><a href="#DRY-Don’t-Repeat-Yourself-原则" class="headerlink" title="DRY (Don’t Repeat Yourself) 原则"></a>DRY (Don’t Repeat Yourself) 原则</h2><p>JavaScript 是一门编程语言，和其它计算机语言一样，在你编码的过程中需要有避免重复代码和逻辑的意识，注意不断优化自己的代码。</p>
<p>以免写出看似体系庞大而可靠，实则冗余且迟滞的代码，埋下 bug 隐患，影响团队伙伴阅读代码、协作开发的效率，也耽误自己以后优化和迭代项目。</p>
<p>因此，其中重要的原则之一就是 <strong>DRY (Don’t Repeat Yourself)</strong> 原则。</p>
<p>当你第一次写下某段代码，之后在另一个地方又写下或粘贴同样的代码，你就应该有需要消除和提取重复代码的冲动了。</p>
<p>等到第三次，再另一个地方又出现同样的代码时，就可以考虑行动起来，提取共用的代码而不是又重复一遍。</p>
<h2 id="函数复用、公用库"><a href="#函数复用、公用库" class="headerlink" title="函数复用、公用库"></a>函数复用、公用库</h2><p>最基本的方法，就是把重复代码提取成复用的函数。</p>
<h3 id="对话框展示函数"><a href="#对话框展示函数" class="headerlink" title="对话框展示函数"></a>对话框展示函数</h3><p>例如，在页面某处有一个弹出 Dialog 的逻辑，写下了这样的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $dialog1 = $(<span class="string">'&lt;div class="dialog-box"&gt;'</span> + </span><br><span class="line">                 <span class="string">'  &lt;p class="dialog-msg"&gt;&lt;/p&gt;'</span> +</span><br><span class="line">                 <span class="string">'  &lt;a class="dialog-btn" close-dialog&gt;确定&lt;/a&gt;'</span> + </span><br><span class="line">                 <span class="string">'&lt;/div&gt;'</span>)</span><br><span class="line">                .on(<span class="string">'click'</span>,<span class="string">'[close-dialog]'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                  $(<span class="keyword">this</span>).closest(<span class="string">'.dialog-box'</span>).hide();</span><br><span class="line">                &#125;)</span><br><span class="line">                .find(<span class="string">'.dialog-msg'</span>)</span><br><span class="line">                .text(<span class="string">'登陆成功！'</span>);</span><br><span class="line">$(<span class="string">'body'</span>).append($dialog1);</span><br></pre></td></tr></table></figure>
<p>之后又增加了一个类似的 Toast 消息：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $dialog2 = $(<span class="string">'&lt;div class="dialog-box"&gt;'</span> + </span><br><span class="line">                 <span class="string">'  &lt;p class="dialog-msg"&gt;&lt;/p&gt;'</span> +</span><br><span class="line">                 <span class="string">'  &lt;a class="dialog-btn" close-dialog&gt;确定&lt;/a&gt;'</span> + </span><br><span class="line">                 <span class="string">'&lt;/div&gt;'</span>)</span><br><span class="line">                .on(<span class="string">'click'</span>, <span class="string">'[close-dialog]'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                  $(<span class="keyword">this</span>).closest(<span class="string">'.dialog-box'</span>).hide();</span><br><span class="line">                &#125;)</span><br><span class="line">                .find(<span class="string">'.dialog-msg'</span>)</span><br><span class="line">                .text(<span class="string">'评论发送失败！'</span>);</span><br><span class="line">$(<span class="string">'body'</span>).append($dialog2);</span><br></pre></td></tr></table></figure>
<p>这段代码与上面那段几乎所是相同的，区别只在于提示语。</p>
<p>明显没必要这样重复，可以提取出一个通用的兑换框展示函数 <strong>showDialog</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showDialog</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $dialog = $(<span class="string">'&lt;div class="dialog-box"&gt;'</span> + </span><br><span class="line">                  <span class="string">'  &lt;p class="dialog-msg"&gt;&lt;/p&gt;'</span> +</span><br><span class="line">                  <span class="string">'  &lt;a class="dialog-btn" close-dialog&gt;确定&lt;/a&gt;'</span> + </span><br><span class="line">                  <span class="string">'&lt;/div&gt;'</span>)</span><br><span class="line">                  .on(<span class="string">'click'</span>, <span class="string">'[close-dialog]'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    $(<span class="keyword">this</span>).closest(<span class="string">'.dialog-box'</span>).hide();</span><br><span class="line">                  &#125;)</span><br><span class="line">                  .find(<span class="string">'.dialog-msg'</span>)</span><br><span class="line">                  .text(msg);</span><br><span class="line">  $(<span class="string">'body'</span>).append($dialog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showDialog(<span class="string">'登陆成功！'</span>);</span><br><span class="line"></span><br><span class="line">showDialog(<span class="string">'评论发送失败！'</span>);</span><br></pre></td></tr></table></figure>
<p>提取<strong>共用函数</strong>可以说是最基本的编程思想了。</p>
<p>这样之后需要增加新的消息，或是对原有的所有提示消息做调整和修复时，不需要修改散落在四处的代码，只需修改一处，效率大大提升。</p>
<p>有一些代码甚至不止可以用于一个项目，还可以在今后的项目开发中继续复用，这些函数逻辑可以提取成<strong>公用代码库</strong>，节省今后项目开发的时间。</p>
<h2 id="抽象成对象-类"><a href="#抽象成对象-类" class="headerlink" title="抽象成对象/类"></a>抽象成对象/类</h2><p>上面的思想概括起来，其实就是将处理一类事务的过程，以函数的形式复用。</p>
<p>是一种相对初级的复用思想，随着业务逻辑逐渐复杂，这种办法的效果也越来越弱。</p>
<p>结果就是，这样写出来的 js 文件，到达一定规模之后，其中虽然没什么重复代码，但却有着几十上百个函数。阅读者理清其中的顺序和关系会很耗时，难以保证可读性。</p>
<p>而且函数形式的复用，并不能很好的处理带属性、状态一类的情况。</p>
<p>比如上面的对话框函数，如果要给对话框增加拖动的处理函数，还要在记录坐标、层级、打开状态等等属性时，需要手动从外部传入很多变量来处理。</p>
<p>导致原本是对话框相关的逻辑和数据，却被分散到了文件内的不同地方，需要做属性增减时很难集中调整。</p>
<p>继续增加函数形式的控制逻辑，也容易与其他函数混在一起。项目合作的同事稍不注意，就容易插入其他函数把它们打散。</p>
<p>最后赶出来的项目或许能正常运行，但内部代码却是互相穿插、混乱不堪的<strong>意大利面条代码</strong>，几乎无法维护。</p>
<p>所以计算机软件工程的前人们，探索出了<strong>面向对象</strong>的编程思想。</p>
<h3 id="对话框类的定义"><a href="#对话框类的定义" class="headerlink" title="对话框类的定义"></a>对话框类的定义</h3><p>让我们从头想想，<strong>对话框</strong>是什么呢？</p>
<p>它应该是具有特定坐标、宽高、背景色等样式，可以设定其内容、坐标、控制按键等属性的绝对定位的特定元素。</p>
<p>那么有没有这样一种办法，使我们可以在需要使用对话框时，做到：</p>
<ul>
<li>简单快速地创建对话框；</li>
<li>调用API就可以调整内容、移动、展示、收起对话框；</li>
<li>并且使不同对话框操作接口一致，自身数据却互不干扰；</li>
<li>有必要时，还可以在原有接口基础上快速增加新的特性呢？</li>
</ul>
<p>刚才我们提到的这些，可以通过面向对象的<strong>继承、封装</strong>和<strong>多态</strong>来实现。</p>
<p>不过由于 JavaScript 的特殊性，<strong>多态</strong>在鸭子模式下的体现并不明显，暂且不提。先从一些基本概念开始说起。</p>
<p>上一步里，我们抽象出了对话框的基本概念，也就是我们需要的<strong>对话框</strong>大致上是个什么的东西。</p>
<p>运用面向对象的思想，我们可以把它们作为其成员属性、方法，来定义出一个<strong>对话框类</strong>。</p>
<p>为了方便新同学直接在浏览器里测试代码，这里采用 ES5 的类写法举例：</p>
<blockquote>
<p>关于 JavaScript 的原型链和面相对象的关系，本文暂不深入说明，以免初学者混淆。</p>
<p>大家可以先学会运用现有的方式，先知其然后知其所以然，通过实践记忆之后再深入了解原理也会更容易上手。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对话框类的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dialog</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// 创建相应 dom，记录到当前构建的对象内</span></span><br><span class="line">  <span class="keyword">this</span>.$dom = $(<span class="string">'&lt;div class="dialog-box"&gt;'</span> + </span><br><span class="line">                <span class="string">'  &lt;p class="dialog-msg"&gt;&lt;/p&gt;'</span> +</span><br><span class="line">                <span class="string">'  &lt;a class="dialog-btn" close-dialog&gt;确定&lt;/a&gt;'</span> + </span><br><span class="line">                <span class="string">'&lt;/div&gt;'</span>)</span><br><span class="line">                .on(<span class="string">'click'</span>, <span class="string">'[close-dialog]'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                  self.hide();</span><br><span class="line">                &#125;);</span><br><span class="line">  $(<span class="string">'body'</span>).append(<span class="keyword">this</span>.$dom);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对话框的可用方法</span></span><br><span class="line">Dialog.prototype = &#123;</span><br><span class="line">  <span class="comment">// 记录构造函数</span></span><br><span class="line">  <span class="keyword">constructor</span>: Dialog,</span><br><span class="line">  // 设置内容</span><br><span class="line">  setContent: function (content) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$dom.find(<span class="string">'.dialog-msg'</span>).text(content);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 展示对话框</span></span><br><span class="line">  show: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.$dom.show();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 收起对话框</span></span><br><span class="line">  hide: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.$dom.hide();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>首先声明对话框类 <strong>Dialog</strong> 的构造函数，之后每个对话框都将通过这个函数构建出具体的实例。</p>
<p>其中通过操作 <strong>this</strong>，可以使所有对话框都有 DOM 对象可供操作，且互相独立不受干扰（比如对话框1和对话框2都具有 <strong>$dom</strong> 的属性，修改对话框1的 <strong>$dom</strong> 时，对话框2的 <strong>$dom</strong> 不会受到任何影响，反之亦然）。</p>
<p>然后，增加了几个 <strong>Dialog</strong> 原型函数 <strong>show, hide, destroy</strong>。这几个函数被称为类的<strong>方法</strong>。</p>
<p>所有对话框都可以调用这些方法，与构造函数一样，其中也可以操作 <strong>this</strong> 来达成不同实例互不干扰的效果。</p>
<h3 id="对话框实例"><a href="#对话框实例" class="headerlink" title="对话框实例"></a>对话框实例</h3><p>完成了最基本的可复用对话框类的创建，只需要通过 new 就可以实例化后使用了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建对话框1</span></span><br><span class="line"><span class="keyword">var</span> dialog1 = <span class="keyword">new</span> Dialog();</span><br><span class="line"><span class="comment">// 设置其内容</span></span><br><span class="line">dialog1.setContent(<span class="string">'登陆成功！'</span>);</span><br><span class="line"><span class="comment">// 展示对话框1</span></span><br><span class="line">dialog1.show();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对话框2</span></span><br><span class="line"><span class="keyword">var</span> dialog2 = <span class="keyword">new</span> Dialog();</span><br><span class="line"><span class="comment">// 设置其内容（不影响对话框1）</span></span><br><span class="line">dialog2.setContent(<span class="string">'评论发送失败！'</span>);</span><br><span class="line"><span class="comment">// 展示对话框2</span></span><br><span class="line">dialog2.show();</span><br><span class="line"><span class="comment">// 3秒后自动收起（同样不影响对话框1）</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  dialog2.hide();</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p>与 <strong>showDialog</strong> 函数相比，这样写有什么优势呢？</p>
<p>首先是逻辑和属性集中化，方便对同一类的成员进行维护和扩展。</p>
<p>通过 <strong>this</strong> 操作每个实例，避免重复的传参，无需手动区分不同实例，灵活又便捷。</p>
<p>而且通过 <strong>IDE</strong> 的解析推断，可以根据对象所属的类型，自动给出属性和方法的智能提示，提升开发效率，避免在函数海中苦苦搜寻，甚至混淆调用。</p>
<p>目前主流的前端自动化都有脚本打包功能，根据类和基本逻辑划分项目文件结构后，维护起来十分清晰便利。</p>
<p>合作开发的同事可以通过查看项目结构，对于流程有个大致概念。</p>
<p>对于顶层逻辑只需要了解主要流程，底层逻辑都被封装入类内对外透明。</p>
<p>每个文件内只需要处理自身相关的逻辑，代码量基本可以控制在400行内，属于最适合维护阅读的程度。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>有其他语言的面向对象开发经验的同学，可能会对 JavaScript 内的类生命写法不解，为什么看起来会这么奇怪。</p>
<p>这是因为 JavaScript 的面向对象是基于原型而非基于类来实现的。</p>
<p>最直观的区别就是其实并不存在真正的类，而是基于对象实例，通过将实例作为构造函数的原型，再通过调用构造函数来产生继承于此的新对象。</p>
<p>这种模式非常灵活，适合 JavaScript 动态脚本语言的开发模式。</p>
<p>但对于新手来说可能会更难理解，实际操作中实现较完美的继承扩展，区分原型和实例的函数也有一定难度，容易造成误解和混淆。</p>
<p>所以 ES6 中提供了更方便的 class 定义方式，目前主流的前端开发框架 React、Vue、Angluar 也都推荐使用 ES6 的新写法。</p>
<p>大家编写 ES5 的模拟类体验和理解后，再通过这些框架的脚手架或者 babel 的 repl 感受 ES6 中定义类的便捷性。</p>
<p>有兴趣的话，可以尝试使用 ES6 再实现上面 dialog 的例子，并扩展出宽高、坐标属性，和对应的调整大小、位置的函数，作为这一期的课后练习吧~</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/04/08/colorful-chart-mail-report-with-phantomjs/" class="prev">PREV</a><a href="/2017/10/25/basic-knowledge-points-for-beginner-2/" class="next">NEXT</a></div><div id="lv-container" data-id="city" data-uid="MTAyMC8zNDQzMi8xMDk2OQ=="></div><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script><div class="copyright"><p>© 2017 - 2020 <a href="http://blog.krimeshu.com">krimeshu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/MikeCoder/hexo-theme-gandalfr" target="_blank">hexo-theme-gandalfr</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1261274049'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1261274049%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script></p></div></footer></div><script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js" crossorigin="anonymous"></script><script src="//cdn.bootcss.com/jquery/3.1.1/jquery.js" crossorigin="anonymous"></script><script>$(document).ready(function() { $('pre').each(function(i, block) { hljs.highlightBlock(block); }); });</script></body></html>