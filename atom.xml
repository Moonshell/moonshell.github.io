<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>亦知亦解</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.krimeshu.com/"/>
  <updated>2020-08-30T09:30:49.363Z</updated>
  <id>http://blog.krimeshu.com/</id>
  
  <author>
    <name>krimeshu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>初探 Vue 3.0 的组装式 API（一）</title>
    <link href="http://blog.krimeshu.com/2020/08/30/vue-3-composition-api-introduction-1/"/>
    <id>http://blog.krimeshu.com/2020/08/30/vue-3-composition-api-introduction-1/</id>
    <published>2020-08-30T09:30:00.000Z</published>
    <updated>2020-08-30T09:30:49.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="（一）响应式数据"><a href="#（一）响应式数据" class="headerlink" title="（一）响应式数据"></a>（一）响应式数据</h1><h2 id="1-简单例子"><a href="#1-简单例子" class="headerlink" title="1. 简单例子"></a>1. 简单例子</h2><p>从最简单的数据绑定开始，在 Vue 2.0 中，我们这样将一个数据绑定到模板的指定位置：</p><p>在组件创建参数的 <code>data</code> 构造函数中返回一个用来绑定的数据对象，其中有个 <code>now</code> 字段，会被渲染到模板内的 <code>.app &gt; p</code> 内。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Now is: &#123;&#123;now.toString()&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">// Vue 2.0</span></span><br><span class="line"><span class="undefined">export default &#123;</span></span><br><span class="line"><span class="undefined">    data() &#123;</span></span><br><span class="line"><span class="undefined">        return &#123;</span></span><br><span class="line"><span class="undefined">            now: new Date(),</span></span><br><span class="line"><span class="undefined">        &#125;;</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">&#125;;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>用 Vue3 的组装 API 实现的话，则是这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue 3.0</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            now: <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-更新数据"><a href="#2-更新数据" class="headerlink" title="2. 更新数据"></a>2. 更新数据</h2><p>奇怪，看起来好像没啥区别，只是把 <code>data</code> 改成了 <code>setup</code> 吗？</p><p>并不是，假如我们现在对这个 DEMO 做个小改动，让它每秒钟刷新一次时间，用 Vue2 大概是这样实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue 2.0</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            now: <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">        setInterval(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.now = <span class="keyword">new</span> <span class="built_in">Date</span>(), <span class="number">1000</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而 Vue3 的等效实现则为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue 3.0</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref, onMounted &#125; <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">        <span class="keyword">const</span> now = ref(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">        onMounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            setInterval(<span class="function"><span class="params">()</span> =&gt;</span> now.value = <span class="keyword">new</span> <span class="built_in">Date</span>(), <span class="number">1000</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            now,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-对比分析"><a href="#3-对比分析" class="headerlink" title="3. 对比分析"></a>3. 对比分析</h2><p>写了太多 Vue 的我们可能已经忘了，Vue2 的代码从标准 JS 模块的角度来看有多奇怪：</p><ul><li><code>mounted</code> 中修改的 <code>this.now</code> 数据是在哪创建的？我们在模块 <code>default</code> 对象的成员里并没有找到对应字段，倒是在 <code>data</code> 内返回的另一个对象中有这个字段；</li><li>而 <code>data</code> 中返回的 <code>now</code> 也不是真正的 <code>this.now</code>，而是 <code>this.now</code> 的初始值，在 <code>data</code> 中 <code>setInterval</code> 修改 <code>now</code> 并不能更新渲染出来的时间；</li><li>如果想复用这个数据和它的更新逻辑，你必须将这样的结构单独写一份，然后通过特殊的 <code>mixin</code> 函数混入到当前组件的构造参数内。</li></ul><p>这一切，是因为<strong>整个模块 <code>default</code> 对象其实是 <code>vm</code> 对象的构造参数。其背后隐藏了对象的创建逻辑，在构造对象时构造参数中的一些不同层级的字段被绑定到了 <code>vm</code> 对象上</strong>。</p><p>不少新手可能都犯过一个错误，在 <code>data</code> 中返回的数据字段和 <code>props</code>、<code>methods</code> 或者 <code>computed</code> 中的字段命名撞车（尤其是使用名为 <code>data</code> 的字段），在编码阶段并不能被 IDE 直接发现。就是因为上面的原因，这些字段创建时隶属于不同的位置，在之后构造时才被绑在了同一个对象上，导致了运行时才能发现的冲突。</p><p>Vue3 中，改成提供 <code>ref</code>、<code>reactive</code>、<code>toRef</code>、<code>onMounted</code> 等函数的形式实现，例子中：</p><ul><li>在 <code>setup</code> 中看到的 <code>now</code> 即是用于绑定的 <code>this.now</code>；</li><li>修改 <code>now.value</code> 即可看到页面状态的更新；</li><li>如果要封装这份数据处理，只需要将 <code>now</code> 和 <code>onMounted</code> 处理提取到同一个函数内，再将 <code>now</code> 返回即可，不再需要黑盒的 <code>mixin</code> 处理。</li></ul><p>可以说 Vue3 是直接将响应数据的创建决定权、生命周期的通知回调，都通过 API 的形式交给了开发者，更直观明了和可控。</p><h2 id="4-API-说明"><a href="#4-API-说明" class="headerlink" title="4. API 说明"></a>4. API 说明</h2><p>下面详细说说常用的几个响应式数据相关 API：<code>ref</code>, <code>reactive</code> 和 <code>toRefs</code>。</p><p><strong>(1) ref</strong></p><p>上面例子中使用到的 <code>ref</code>，可以将一个数据包装成响应式数据代理对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(count.value); <span class="comment">// =&gt; 0</span></span><br><span class="line"></span><br><span class="line">count.value++;</span><br><span class="line"><span class="built_in">console</span>.log(count.value); <span class="comment">// =&gt; 1</span></span><br></pre></td></tr></table></figure><p>当你修改代理对象的 <code>count.value</code> 属性时，模板中使用到 <code>count</code> 的位置将响应数据的变化，更新视图中的数据状态。</p><p><strong>(2) reactive</strong></p><p>对于对象的响应式封装，使用 <code>ref</code> 稍显麻烦：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = ref(&#123;</span><br><span class="line">    count: <span class="number">0</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(state.value.count); <span class="comment">// =&gt; 0</span></span><br><span class="line"></span><br><span class="line">state.value.count++;</span><br><span class="line"><span class="built_in">console</span>.log(state.value.count); <span class="comment">// =&gt; 1</span></span><br></pre></td></tr></table></figure><p>这时可以改为使用 <code>reactive</code>，像操作普通对象的字段一样修改 <code>count</code> 即可更新视图：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">    count: <span class="number">0</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(state.count); <span class="comment">// =&gt; 0</span></span><br><span class="line"></span><br><span class="line">state.count++;</span><br><span class="line"><span class="built_in">console</span>.log(state.count); <span class="comment">// =&gt; 1</span></span><br></pre></td></tr></table></figure><p>对代理对象 <code>state</code> 添加新的字段也可触发视图更新。</p><p><strong>(3) toRefs</strong></p><p>有时候，对象的名字过长，我们想直接在模板内使用对象内部字段，直接使用解构是不行的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">        <span class="keyword">const</span> position = reactive(&#123;</span><br><span class="line">            x: <span class="number">0</span>,</span><br><span class="line">            y: <span class="number">0</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="comment">// 错误，解构出来的 x, y 并没有响应式代理。绑定到模板上后，数据变化无法触发视图更新</span></span><br><span class="line">            ...position,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个情况下，使用 <code>toRefs</code> 处理后再解构赋值即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, toRefs &#125; <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">        <span class="keyword">const</span> position = reactive(&#123;</span><br><span class="line">            x: <span class="number">0</span>,</span><br><span class="line">            y: <span class="number">0</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            ...toRefs(position),</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但需要注意，<code>toRefs</code> 只处理调用时 <code>position</code> 的现有字段，如果在之后对 <code>position</code> 增加新字段，将无法触发视图更新。</p><!-- ## 2. 事件处理## 3. 监听与计算属性## 4. 子级数据传递-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;（一）响应式数据&quot;&gt;&lt;a href=&quot;#（一）响应式数据&quot; class=&quot;headerlink&quot; title=&quot;（一）响应式数据&quot;&gt;&lt;/a&gt;（一）响应式数据&lt;/h1&gt;&lt;h2 id=&quot;1-简单例子&quot;&gt;&lt;a href=&quot;#1-简单例子&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="前端" scheme="http://blog.krimeshu.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vue" scheme="http://blog.krimeshu.com/tags/Vue/"/>
    
      <category term="Vue3" scheme="http://blog.krimeshu.com/tags/Vue3/"/>
    
      <category term="CompositionAPI" scheme="http://blog.krimeshu.com/tags/CompositionAPI/"/>
    
  </entry>
  
  <entry>
    <title>Vue 样式中的深度选择器 /deep/ 和 &gt;&gt;&gt;</title>
    <link href="http://blog.krimeshu.com/2020/07/02/deep-selector-for-vue-scoped-style/"/>
    <id>http://blog.krimeshu.com/2020/07/02/deep-selector-for-vue-scoped-style/</id>
    <published>2020-07-01T16:00:00.000Z</published>
    <updated>2020-08-01T08:52:55.420Z</updated>
    
    <content type="html"><![CDATA[<p>当你使用第三方 UI 框架时，可能会遇到内置样式不满足业务需求，需要亲手修改框架提供组件的默认样式的情况。</p><a id="more"></a><p>比如 UI 框架提供了一个菜单组件 <code>&lt;iv-menu&gt;</code>，但是其中标题文本的效果不符合我们的预期。我们在 Chrome Inspector 中找到对应 DOM，发现 <strong>className</strong> 为 <code>.title</code>，于是就添加了这样的样式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- page.vue --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"scss"</span> <span class="attr">scoped</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    .page &#123;</span></span><br><span class="line"><span class="undefined">        margin: 0;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    .iv-menu &#123;</span></span><br><span class="line"><span class="undefined">        background-color: #ffffff;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    .iv-menu .title &#123;</span></span><br><span class="line"><span class="undefined">        font-size: 12px;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"page"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">iv-menu</span> <span class="attr">title</span>=<span class="string">"标题"</span>&gt;</span><span class="tag">&lt;/<span class="name">iv-menu</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结果——添加的样式并没有生效。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>因为 <strong>page.vue</strong> 这里我们使用了 <code>scoped</code> 样式作用域，Vue 会为当前模板内所有元素会被增加一个特殊属性（如：<code>[data-v-5ef48958]</code>），并且为所有样式选择器最后一级添加这个属性的选择器。</p><p>生成的样式和 DOM 大致是这样的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    .page[data-v-5ef48958] &#123;</span></span><br><span class="line"><span class="undefined">        margin: 0;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"page"</span> <span class="attr">data-v-5ef48958</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到 <code>.page</code> 选择器自动变成了 <code>.page[data-v-5ef48958]</code>，从而达到这个组件的 <code>.page</code> 样式不污染其它同名样式的效果。</p><p>而这个处理，也就是导致我们无法修改子组件内样式的原因。毕竟，不污染子组件样式其实就是样式作用域本身预期的效果。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>上面例子中修改 <code>&lt;iv-menu&gt;</code> 组件内标题的例子，生成代码大致如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"page"</span> <span class="attr">data-v-5ef48958</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"iv-menu"</span> <span class="attr">data-v-5ef48958</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应样式为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.page</span><span class="selector-attr">[data-v-5ef48958]</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.iv-menu</span><span class="selector-attr">[data-v-5ef48958]</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.iv-menu</span> <span class="selector-class">.title</span><span class="selector-attr">[data-v-5ef48958]</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>.page[data-v-5ef48958]</code> 和 <code>.iv-menu[data-v-5ef48958]</code> 的样式对应的 DOM 选择器都是正确的。</p><p>但是对于 <code>.iv-menu</code> 内部的 <code>.title</code>，Vue 的样式作用域处理逻辑认为它属于当前组件，所以生成的选择器是 <code>.iv-menu .title[data-v-5ef48958]</code>。</p><p>而实际需要的选择器其实是 <code>.iv-menu[data-v-5ef48958] .title</code>。</p><p>也就是说，只需要告诉 Vue 的样式作用域处理逻辑：“<em>我们这个组件只管到 <code>.iv-menu</code>，后面的 <code>.title</code> 是属于更深的子组件样式，不要加作用域处理</em>”，就行了。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>而 Vue 已经提供了这样的告知方法，就是深度选择器 <code>/deep/</code>。只需要在组件样式内加入它就行了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- page.vue --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"scss"</span> <span class="attr">scoped</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.page</span> &#123;</span></span><br><span class="line"><span class="undefined">        margin: 0;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.iv-menu</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">background-color</span>: <span class="selector-id">#ffffff</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">    .iv-menu /deep/ .title &#123;</span></span><br><span class="line"><span class="undefined">        font-size: 12px;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"page"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">iv-menu</span> <span class="attr">title</span>=<span class="string">"标题"</span>&gt;</span><span class="tag">&lt;/<span class="name">iv-menu</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果遇到 SASS 处理器不识别 <code>/deep/</code> 而报错，可以改成 <code>&gt;&gt;&gt;</code> 或者 <code>::v-deep</code> 操作符，三者是一样的。</p><blockquote><p>官方说明：<a href="https://vue-loader.vuejs.org/zh/guide/scoped-css.html#%E6%B7%B1%E5%BA%A6%E4%BD%9C%E7%94%A8%E9%80%89%E6%8B%A9%E5%99%A8" target="_blank" rel="noopener">https://vue-loader.vuejs.org/zh/guide/scoped-css.html#%E6%B7%B1%E5%BA%A6%E4%BD%9C%E7%94%A8%E9%80%89%E6%8B%A9%E5%99%A8</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你使用第三方 UI 框架时，可能会遇到内置样式不满足业务需求，需要亲手修改框架提供组件的默认样式的情况。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://blog.krimeshu.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="vue" scheme="http://blog.krimeshu.com/tags/vue/"/>
    
      <category term="style" scheme="http://blog.krimeshu.com/tags/style/"/>
    
      <category term="less" scheme="http://blog.krimeshu.com/tags/less/"/>
    
      <category term="sass" scheme="http://blog.krimeshu.com/tags/sass/"/>
    
  </entry>
  
  <entry>
    <title>让 WebStorm 自动识别 Webpack 的 alias 配置</title>
    <link href="http://blog.krimeshu.com/2020/05/24/webstorm-detect-webpack-alias-config/"/>
    <id>http://blog.krimeshu.com/2020/05/24/webstorm-detect-webpack-alias-config/</id>
    <published>2020-05-24T06:20:00.000Z</published>
    <updated>2020-08-01T08:52:55.423Z</updated>
    
    <content type="html"><![CDATA[<p>我们都经常遇到这个情况，在 Web 项目目录结构划分得细致之后，从某个子组件引用公共模块时，如果使用准确的相对路径，路径可能会变得相当长：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">├── common</span><br><span class="line">│   └── net.js</span><br><span class="line">└── pages</span><br><span class="line">    ├── index</span><br><span class="line">    │   └── top-bar.vue</span><br><span class="line">    └── index.vue</span><br></pre></td></tr></table></figure><p>此时，如果在 <strong>top-bar.vue</strong> 里引用 <strong>net.js</strong>，路径将会是这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> net <span class="keyword">from</span> <span class="string">'../../common/net.js'</span></span><br></pre></td></tr></table></figure><p>某些情况还需要写好几个 <code>../</code>，而且一旦某些逻辑分离成单独组件时，放在了不同层级深度的目录里，这些路径代码就得一一修复引用。</p><p>所以我们经常在 Webpack 里做类似这样的配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    resolve: &#123;</span><br><span class="line">        alias: &#123;</span><br><span class="line">            <span class="string">'@'</span>: <span class="built_in">require</span>(<span class="string">'path'</span>).join(__dirname, <span class="string">'./src'</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后不管需要用到公共组件的文件在哪个层级，都可以直接写成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> net <span class="keyword">from</span> <span class="string">'@/common/net.js'</span></span><br></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>虽然这么写是能通过编译了，但是编码过程中又会发现一些体验上的不便。</p><p>在 IDE 中通过准确的路径引用的文件，可以提供便捷的定义跳转、函数提示、自动完成等功能。</p><p>而通过别名引用的文件，IDE 似乎就爱莫能助了，按住 ctrl/cmd 看不见跳转链接、写出函数名的前几个字母也不会出现智能提示、对于公用组件的函数 Js Doc 也无法直接看到。</p><p>这都 2020 年了，难道没有 IDE 支持常用前端项目结构的 alias 路径解析吗？</p><p>答案是有的，WebStorm 里就提供了 Webpack 配置文件的 alias 路径解析。</p><p>但是有人可能和我一样，虽然写了 alias，而且确实是官方的语法。但是 WebStorm 并没有对应的提示，那么是哪里出了问题呢？</p><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>为了定位问题，我先创建一个最基础的 Webpack 项目，然后通过 WebStorm 打开，发现 alias 里的路径全都能正常解析。</p><p>并没有什么特殊字符或者目录层级的问题，使用 <code>@</code>、<code>@@</code>、<code>{SRC}</code> 等命名都是可以正常识别和提示的。</p><p>但是完全相同的配置，在我的另一个旧项目里就无法识别了。</p><p>这个现有项目相比基础的项目，多了构建环境区分、多页面入口检测、各类资源 loader、后置服务器环境配置任务等很多内容，一一排除的话工作量有点大。</p><p>这时，突然发现每次修改 <strong>webpack.conf.js</strong> 后 WebStorm 的输出窗口里是有相应提示的。只不过对于解析失败的情况，给出的错误信息非常模糊，只说是一个 <code>default</code> 关键字不存在的异常。</p><p>看到 <code>default</code> 首先想到的是 ES6 模块的默认输出对象，但是项目配置是用 CommonJS 写的，并没有使用 <code>export default</code>。倒是根据启动时设定的环境变量，在入口 <strong>webpack.config.js</strong> 内通过 <code>switch</code> 引入了不同的任务配置（<strong>development</strong>/<strong>production</strong>），而这个 <code>switch</code> 里没有编写 <code>default</code> 的处理。</p><p>补充了 <code>default</code> 的情况后，WebStorm 的输出窗口里不再提示 <code>default</code> 异常，但还是提示了另一个错误。不过从错误信息的变化看来，WebStorm 对于 Webpack 配置文件的解析不像是静态解析，更可能是后台执行了一遍 <strong>webpack.confi.js</strong>，然后取了返回结果。</p><p>于是在 <strong>webpack.config.js</strong> 内，拼装配置的过程中，添加了一段代码，向当前项目目录内输出了一个临时文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'fs'</span>).writeFileSync(__dirname + <span class="string">'/detect.log'</span>, <span class="string">'Created:'</span> + <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br></pre></td></tr></table></figure><p>如果 WebStorm 偷偷执行了配置脚本，这边也能通过是否出现 <strong>detect.log</strong> 发现它的踪迹。</p><p>果然，保存配置文件刚过了一会儿，并没有启动 Webpack 任务，项目目录中却出现了一个 <strong>detect.log</strong>。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>既然摸到了 WebStorm 检测的踪迹，接下来就可以开始顺着踪迹逐步定位问题了。</p><p>通过在配置文件不同位置打点输出到刚才的临时日志文件，就能定位到项目配置里到底是哪里影响了 WebStorm 的检测了。</p><p>这边主要是两个情况：一是项目中的附加参数为空时取不到对应配置；二是某些情况下通过 <code>realine</code> 让用户输入相关配置参数，在 WebStorm 检测时是超时无效的。</p><p>将 WebStorm 检测时的 <code>process.env</code> 打印到文件内，对比正常启动任务和 WebStorm 检测的不同环境变量，针对后台检测时做好跳过处理后，终于项目里也能正常检测到定义的 alias 了，问题解决。</p><p>如果大家在使用 WebStorm 的过程中，也遇到类似的问题，可以参考这个方案进行定位和解决问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们都经常遇到这个情况，在 Web 项目目录结构划分得细致之后，从某个子组件引用公共模块时，如果使用准确的相对路径，路径可能会变得相当长：&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://blog.krimeshu.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://blog.krimeshu.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Webpack" scheme="http://blog.krimeshu.com/tags/Webpack/"/>
    
      <category term="WebStorm" scheme="http://blog.krimeshu.com/tags/WebStorm/"/>
    
  </entry>
  
  <entry>
    <title>Weex 开发新手上路 - (2) 前端避坑篇</title>
    <link href="http://blog.krimeshu.com/2019/05/22/start-journy-to-the-weex-1/"/>
    <id>http://blog.krimeshu.com/2019/05/22/start-journy-to-the-weex-1/</id>
    <published>2019-05-21T16:00:00.000Z</published>
    <updated>2020-08-01T08:52:55.421Z</updated>
    
    <content type="html"><![CDATA[<p>接入 WeexSDK 后，前端开发者编写 Weex 页面时会发现，Weex 页面和以前写的 Web 页面还是有一定区别的，一不注意就踩坑了。这里把常见的一些坑列出来，希望能让大家少走弯路：</p><a id="more"></a><h2 id="页面模板"><a href="#页面模板" class="headerlink" title="页面模板"></a>页面模板</h2><p>页面模板方面，只要注意官方文档内提到哪些组件，以及自己安装的第三方组件，记住只使用这些标签来编写模板即可。</p><p>其它经常踩的坑只有一个：文本必须放在 <strong>text</strong> 组件内，<strong>a</strong> 标签内也是如此。且只能使用 Mustache 语法作为节点内容输出，暂不支持 <code>v-text</code> 指令输出。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Wrong --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">"url1"</span>&gt;</span>&#123;&#123;text1&#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">"url1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">v-text</span>=<span class="string">"text1"</span>&gt;</span><span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Right --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">"url1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span>&gt;</span>&#123;&#123;text1&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="页面样式"><a href="#页面样式" class="headerlink" title="页面样式"></a>页面样式</h2><p>样式方面，需要注意的就比较多了。直接当作 CSS 来写，最可能发生的结果就是样式失效白屏。</p><p>除了官方文档提到的属性外，还有不少需要留意的地方。</p><h3 id="1-仅支持单-class-选择器，不支持样式继承"><a href="#1-仅支持单-class-选择器，不支持样式继承" class="headerlink" title="1. 仅支持单 class 选择器，不支持样式继承"></a>1. 仅支持单 class 选择器，不支持样式继承</h3><p>Weex 样式内不支持标签选择器、属性选择器、ID选择器、后代和子层级选择器、相邻选择器，以及 CSS3 中增加的各种计数选择器等。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Wrong */</span></span><br><span class="line"><span class="selector-tag">text</span> &#123;</span><br><span class="line">    color: #333333;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[checked]</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#link1</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> <span class="selector-tag">a</span>, <span class="selector-class">.header</span> &gt; <span class="selector-tag">p</span>, <span class="selector-class">.icon</span> + <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(0,0,0, 0.05);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说了这么多，其实只需要记住一种：Weex 内目前仅支持 <code>.className</code> 式的类型选择器。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Right */</span></span><br><span class="line"><span class="selector-class">.class1</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(0,0,0,0.05);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.text1</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">24px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#333333</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>伪类方面，Weex 支持四种伪类：<code>active</code>, <code>focus</code>, <code>disabled</code>, <code>enabled</code>。</p><p>所有组件都支持 <code>active</code>, 但只有 <code>input</code> 组件和 <code>textarea</code> 组件支持 <code>focus</code>, <code>enabled</code>, <code>disabled</code>。</p><h3 id="2-只支持-px-单位，不支持百分比宽高"><a href="#2-只支持-px-单位，不支持百分比宽高" class="headerlink" title="2. 只支持 px 单位，不支持百分比宽高"></a>2. 只支持 px 单位，不支持百分比宽高</h3><p>根据官方文档的描述，我们知道 Weex 内只能使用像素值单位 <code>px</code>。</p><blockquote><ul><li><p>Weex 不支持类似 <code>em</code>、<code>rem</code>、<code>pt</code>,<code>%</code> 这样的 CSS 标准中的其他长度单位；</p></li><li><p>单位 <code>px</code> 不可省略，否则在 Web 环境无法正确渲染；</p></li></ul></blockquote><p>且这个单位并非真实屏幕像素，而是把所有屏幕视为 <code>750px</code> 宽度，<code>1px</code> 则是<strong>屏幕宽度的七百五十分之一</strong>，而非一个真实像素的宽度，以此来实现不同设备屏幕宽度的适配。</p><h3 id="3-默认纵向布局，子元素拉伸填充侧轴"><a href="#3-默认纵向布局，子元素拉伸填充侧轴" class="headerlink" title="3. 默认纵向布局，子元素拉伸填充侧轴"></a>3. 默认纵向布局，子元素拉伸填充侧轴</h3><p>Weex 中支持且仅支持 flexbox 布局方式。但你会发现，在不指定 <code>flex-direction</code> 属性的时候内部元素是纵向布局的。</p><p>因为 Weex 中默认 <code>flex-direction</code> 为 <code>column</code> 而不是 <code>row</code>。</p><p>而且不设置子元素的宽度，父元素的 <code>align-items</code> 为默认的 <code>stretch</code> 时，子元素将自动拉伸填充侧轴宽度。</p><img src="/images/start-journy-to-the-weex/flex-direction-and-stretch.png" title="cover"><p>由于 Weex 不支持 <code>%</code> 单位，某个组件需要适配父组件宽度的时候，可以通过这个方式实现宽度 <code>100%</code> 的效果。</p><h3 id="4-属性名尽量用全称"><a href="#4-属性名尽量用全称" class="headerlink" title="4. 属性名尽量用全称"></a>4. 属性名尽量用全称</h3><p>在完成本文章时，使用 Weex 版本 <code>v1.3.11</code> 测试以下样式写法的情况如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.t1</span> &#123;   <span class="comment">/* 有效 */</span></span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.t2</span> &#123;   <span class="comment">/* 无效 */</span></span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.t3</span> &#123;   <span class="comment">/* 有效 */</span></span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.t4</span> &#123;   <span class="comment">/* 无效 */</span></span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.t5</span> &#123;   <span class="comment">/* 有效 */</span></span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">border-style</span>: solid;</span><br><span class="line">    <span class="attribute">border-color</span>: blue;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">border-top-width</span>: <span class="number">2px</span>;</span><br><span class="line">    <span class="attribute">border-top-style</span>: dashed;</span><br><span class="line">    <span class="attribute">border-top-color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.t6</span> &#123;   <span class="comment">/* 无效 */</span></span><br><span class="line">    <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.t7</span> &#123;   <span class="comment">/* 有效 */</span></span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，使用简写形式书写的样式，Weex 不一定支持，所以在 Weex 内尽量使用全称的样式，以免失效。</p><h3 id="5-background-image-不能使用图片资源"><a href="#5-background-image-不能使用图片资源" class="headerlink" title="5. background-image 不能使用图片资源"></a>5. background-image 不能使用图片资源</h3><p>尝试在 Weex 内使用 <code>background-image</code> 样式引入图片，然而并没有效果，官方文档内此属性也只用来实现背景色渐变。</p><p>看来 Weex 内应该是只能 <code>image</code> 组件展示图片资源了。</p><h3 id="6-多行等分布局问题"><a href="#6-多行等分布局问题" class="headerlink" title="6. 多行等分布局问题"></a>6. 多行等分布局问题</h3><p>之前说过，默认子元素侧轴拉伸对齐的情况下，不设置子元素宽度即可实现宽度 <code>100%</code> 的适配。</p><p>如果子元素需要等分父元素宽度，只要使他们的 <code>flex-grow</code> 权重一致即可，但这个适配方案只能处理单行的情况。</p><p>对于 Web 页面 flex 多行布局的情况，我们给父元素设置 <code>flex-wrap: wrap;</code> 属性后，通常根据每行子元素数量设定子元素宽度的百分比。如每行两个子元素时，就给它们设置 <code>width: 50%;</code>。</p><p>但之前说过，Weex 内不支持百分比单位，而 <code>flex-grow</code> 达不到这样的效果。</p><p>所以只能假定，父元素一定是占满屏幕宽度，子元素根据 <code>750px/n</code> 来设置宽度。或者从父组件，通过属性传递告知子组件宽度，再对子组件内的子元素进行宽度计算适配，流程较复杂，且样式部分耦合到了脚本逻辑内。</p><p>目前暂时没有想到更好的方案，只能假定父元素一定是 <code>750px</code> 宽度处理，日常业务一般也是这样的情况，只能保持警惕，遇到这样的情况时注意适配了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接入 WeexSDK 后，前端开发者编写 Weex 页面时会发现，Weex 页面和以前写的 Web 页面还是有一定区别的，一不注意就踩坑了。这里把常见的一些坑列出来，希望能让大家少走弯路：&lt;/p&gt;
    
    </summary>
    
      <category term="node.js" scheme="http://blog.krimeshu.com/categories/node-js/"/>
    
    
      <category term="node.js" scheme="http://blog.krimeshu.com/tags/node-js/"/>
    
      <category term="weex" scheme="http://blog.krimeshu.com/tags/weex/"/>
    
  </entry>
  
  <entry>
    <title>Weex 开发新手上路 - (1) 启程踩坑篇</title>
    <link href="http://blog.krimeshu.com/2019/03/22/start-journy-to-the-weex-0/"/>
    <id>http://blog.krimeshu.com/2019/03/22/start-journy-to-the-weex-0/</id>
    <published>2019-03-21T16:00:00.000Z</published>
    <updated>2020-08-01T08:52:55.420Z</updated>
    
    <content type="html"><![CDATA[<p>最近，面对产品经理们越来越任性的需求、测试同学越来越火眼睛睛的眼力，不由得感觉到：WebView 是有极限的——该试试更贴近原生的框架了！ </p><p>什么是 Weex ？官方文档中的定义是 <strong>“Weex 是使用流行的 Web 开发体验来开发高性能原生应用的框架”</strong>。</p><p>关于如何使用 Weex，官方文档中已经有步骤说明。但你按照文档开始尝试时，还是可能会遇到一些没提及的问题。</p><p>这里对之前遇到的问题和解决方法做个记录，大家如果遇到类似情况可以参考处理。</p><a id="more"></a><p>基本流程请阅读 <a href="https://weex.apache.org/zh/guide/introduction.html" target="_blank" rel="noopener">Weex 官方文档</a>，这里不再赘述。</p><h1 id="SDK-安装失败"><a href="#SDK-安装失败" class="headerlink" title="SDK 安装失败"></a>SDK 安装失败</h1><p>开始的第一个问题：全局安装 weex-toolkit 失败。</p><p>搜索参考 <a href="https://npm.community/t/global-installs-sudo-npm-i-g-fail-on-mac-after-6-5-upgrade-works-fine-after-6-4-1-downgrade/4082" target="_blank" rel="noopener">Global installs (sudo npm i -g) fail on Mac after 6.5 upgrade. Works fine after 6.4.1 downgrade.</a></p><p>通过修复以前安装的模块和 cache 权限解决，执行以下命令（请确认在自己的个人电脑环境下执行）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R $(whoami) ~/.npm</span><br><span class="line">sudo chown -R $(whoami) /usr/local/lib</span><br><span class="line">sudo chown -R $(whoami) /usr/local/bin</span><br></pre></td></tr></table></figure><p>将配置修复后，终于顺利安装了 weex-toolkit。</p><h1 id="启动-iPhone-调试失败"><a href="#启动-iPhone-调试失败" class="headerlink" title="启动 iPhone 调试失败"></a>启动 iPhone 调试失败</h1><p>一路继续创建项目、运行 Web 版 demo、加入 iOS 平台支持、执行 <code>weex run ios</code> 启动 iOS 调试——</p><p>新问题出现了。</p><p>如果没安装 Xcode 的话，这一步会提示 ios-deploy 安装失败：</p><blockquote><p>npm ERR! <a href="mailto:ios-deploy@1.9.4" target="_blank" rel="noopener">ios-deploy@1.9.4</a> preinstall: <code>./src/scripts/check_reqs.js &amp;&amp; xcodebuild</code></p></blockquote><p>这个情况的话，只要从 AppStore 安装 Xcode 即可。</p><p>首次启动点击确认同意协议、确定安装相关开发组件，再次尝试执行 <code>weex run ios</code>，就不会出现刚才的问题了。</p><h1 id="CocoaPods-的安装"><a href="#CocoaPods-的安装" class="headerlink" title="CocoaPods 的安装"></a>CocoaPods 的安装</h1><p>这次 ios-deploy 安装成功了，但之后马上发现还是无法启动 iOS 调试：</p><blockquote><p>Command failed: pod update</p><p>/bin/sh: pod: command not found</p></blockquote><p>搜索错误关键字 <code>pos update</code>，得知需要安装 cocoapods，似乎是一个 iOS 的第三方开源组件库管理器。</p><p>执行 <code>sudo gem install cocoapods</code>，等半天后提示从 <a href="https://ruby.taobao.org" target="_blank" rel="noopener">https://ruby.taobao.org</a> 下载失败。</p><p>然后发现，这个站点居然停止维护了: <a href="https://www.oschina.net/news/71749/taobao-gems-ruby-china" target="_blank" rel="noopener">taobao Gems 源已停止维护，现由 ruby-china 提供镜像服务</a></p><p>于是更换源，网上搜了几个，换了半天都没用。</p><p>怀疑是公司的内网代理问题，但 proxifier 里并没有反应，终端里输出 <code>$http_proxy</code> 也是正确的代理地址。</p><p>最后通过手动添加 <code>--http-proxy</code> 参数，终于安装成功了……</p><p>各种常用工具的配置方法: <a href="https://cloud.tencent.com/developer/article/1114138" target="_blank" rel="noopener">设置 git/npm/bower/pip/gem镜像或代理</a></p><h1 id="安装完毕"><a href="#安装完毕" class="headerlink" title="安装完毕"></a>安装完毕</h1><p>经过半天的折腾，环境终于安装完毕，可以在 iPhone 模拟器内启动项目了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近，面对产品经理们越来越任性的需求、测试同学越来越火眼睛睛的眼力，不由得感觉到：WebView 是有极限的——该试试更贴近原生的框架了！ &lt;/p&gt;
&lt;p&gt;什么是 Weex ？官方文档中的定义是 &lt;strong&gt;“Weex 是使用流行的 Web 开发体验来开发高性能原生应用的框架”&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;关于如何使用 Weex，官方文档中已经有步骤说明。但你按照文档开始尝试时，还是可能会遇到一些没提及的问题。&lt;/p&gt;
&lt;p&gt;这里对之前遇到的问题和解决方法做个记录，大家如果遇到类似情况可以参考处理。&lt;/p&gt;
    
    </summary>
    
      <category term="node.js" scheme="http://blog.krimeshu.com/categories/node-js/"/>
    
    
      <category term="node.js" scheme="http://blog.krimeshu.com/tags/node-js/"/>
    
      <category term="weex" scheme="http://blog.krimeshu.com/tags/weex/"/>
    
  </entry>
  
  <entry>
    <title>用 PhantomJS 让邮件报表图文并茂（二）完善篇</title>
    <link href="http://blog.krimeshu.com/2018/08/24/colorful-chart-mail-report-with-phantomjs-1/"/>
    <id>http://blog.krimeshu.com/2018/08/24/colorful-chart-mail-report-with-phantomjs-1/</id>
    <published>2018-08-23T16:00:00.000Z</published>
    <updated>2020-08-01T08:52:55.418Z</updated>
    
    <content type="html"><![CDATA[<p>根据上一篇文章已经可以实现报表邮件系统的初步 DEMO 了，但其实只是提供了基本的思路。</p><p>实际部署过程中，还会遇到各种各样问题，我在这一篇内一起记录下来，希望能对大家真正地有所帮助。</p><a id="more"></a><h2 id="邮件页面布局兼容性"><a href="#邮件页面布局兼容性" class="headerlink" title="邮件页面布局兼容性"></a>邮件页面布局兼容性</h2><p>在你写完邮件，把它发送到邮件客户端内查看的时候，可能会被邮件客户端里的效果给吓一跳。</p><p>明明在浏览器里好好的，怎么在邮件客户端里就不能看了？不同客户端里效果还各不相同。</p><p>主要原因在于普通网页是由现代浏览器内核的标准来进行加载、解析和渲染的，邮件客户端内的 HTML 渲染内核实现则较为古老，缺少更新。</p><p>而且邮件客户端为确保邮件内容的安全性，会对邮件 HTML 进行预处理，移除修改标签、样式表、脚本，甚至阻止外部引用文件的加载。</p><p>常见的问题有非内联样式失效、边距失效、图片宽度异常、背景图片失效等等。</p><p>基本几个原则如下：</p><ol><li><p>不要写 style 标签，不要用 class 样式，只用元素的样式属性和内联样式；</p></li><li><p>尽量不用 margin 和 padding。使用 table 布局，通过空行、空列拉开间距效果会更为稳定。所有 table 不要并列排列，尽量嵌套在一个 table 里；</p></li><li><p>不要使用 float/position:absolute/position:fixed 等方式定位；</p></li><li><p>图片必须指定宽高和 alt 属性，指定 style=”display:block;border:none;margin:0;padding:0;” 等基本样式；</p></li><li><p>不要简写色值，比如 #FFF，请使用完整的的 #FFFFFF；</p></li></ol><p>想了解得更具体的话，可以阅读参考这几篇文章：</p><blockquote><p><a href="https://www.cnblogs.com/lhweb15/p/6404626.html" target="_blank" rel="noopener">Html Email 邮件html页编写指南</a></p><p><a href="https://swordair.com/principles-on-good-compatibility-html-mail-edm/" target="_blank" rel="noopener">兼容性良好的HTML邮件(EDM)</a></p><p><a href="https://segmentfault.com/a/1190000008864116" target="_blank" rel="noopener">HTML 邮件兼容问题与解决方案</a></p><p><a href="https://templates.mailchimp.com/" target="_blank" rel="noopener">HTML Email Templates Getting Started Guide</a></p></blockquote><h2 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h2><p>重构邮件页面，预览和调试页面效果时，可以使用 <a href="https://www.thunderbird.net/zh-CN" target="_blank" rel="noopener">Thunderbird</a> 向自己的邮箱发送测试邮件。</p><p>再使用 <a href="https://testi.at" target="_blank" rel="noopener">Testi@</a> 模拟各类常见邮件客户端和设备，预览邮件效果。</p><h2 id="Windows-下加载页面失败"><a href="#Windows-下加载页面失败" class="headerlink" title="Windows 下加载页面失败"></a>Windows 下加载页面失败</h2><p>在 Windows 环境下开发测试的同学可能会碰到的一个问题。</p><p>假设本地待处理的网页路径为 <strong>D:\test-mail\index.html</strong>，使用的 PhantomJS 版本为 2.1.1。</p><p>使用 <code>page.open(url, callback)</code> 打开页面时，如果 <code>url</code> 为 <code>fs.absolute(relativePath)</code> 处理出来的绝对路径，即 <strong>D:\test-mail\index.html</strong> 或  <strong>D:/test-mail/index.html</strong>，将会打开失败，回调函数获取的 <code>status</code> 为 <strong>fail</strong>。</p><p>若添加 <strong>file://</strong> 协议头，如 <strong>file://D:/test-mail/index.html</strong>，将能够打开页面，但无法正常加载页面内容，也无法完成截图。</p><p>Linux 和 Mac OS 内，打开 <code>fs.absolute()</code> 处理出来的路径是不会有这个问题的。</p><p>最后发现，Windows 环境下，改用相对路径处理即可……</p><p>所以，保证 PhantomJS 脚本和页面在附近目录，进行开发测试即可。</p><p>部署到服务器上时，定时任务执行目录再指定为绝对路径，避免出现意外，找不到文件的情况。</p><h2 id="字体渲染问题"><a href="#字体渲染问题" class="headerlink" title="字体渲染问题"></a>字体渲染问题</h2><p>当你在本地完成上述邮件测试 DEMO，部署到 linux 服务器上后，可能会发现，图表里的文字全都失踪了。</p><p>这个问题一般是因为 ECharts 未指定使用的字体时，会根据国情默认采用微软雅黑字体。</p><p>而 linux 服务器上没有这个字体文件，就导致 canvas 内文字无法正常渲染了。</p><p>解决办法也不复杂，在服务器上添加相应字体就好。</p><p>首先获得一套“微软雅黑”字体文件（本地路径为 <strong>C:\Windows\Fonts</strong>，两个文件：msyh.ttf 普通、msyhbd.ttf 加粗）</p><p>在服务器的 <strong>/usr/share/fonts</strong> 目录下建立一个子目录，例如 <strong>win</strong>，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/share/fonts/win</span><br></pre></td></tr></table></figure><p>将 msyh.ttf 和 msyhbd.ttf 复制到该目录下，例如这两个文件放在 <strong>/root/Desktop</strong> 下，使用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /root/Desktop</span><br><span class="line">cp msyh.ttf msyhbd.ttf /usr/share/fonts/win/</span><br></pre></td></tr></table></figure><p>建立字体索引信息，更新字体缓存：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/share/fonts/win</span><br><span class="line">mkfontscale</span><br><span class="line">mkfontdir</span><br><span class="line">fc-cache</span><br></pre></td></tr></table></figure><p>字体安装完毕后，再运行测试 DEMO 就 OK 了。</p><h2 id="高分屏适配"><a href="#高分屏适配" class="headerlink" title="高分屏适配"></a>高分屏适配</h2><p>将图表截图，发送邮件到手机上查看后，可能会发现图表的截图在高分屏上的显示效果很不理想。</p><img src="/images/colorful-chart-mail-report-with-phantomjs/font-compare.png" title="popup"><p>这个问题在 Mac 电脑和手机端的屏幕上，看起来会相当明显。</p><p>那么如何截取更清晰的图片素材呢？</p><p>首先，将 PhantomJS 的 page 对象的 <code>zoomFactor</code> 属性设为 2。</p><p>这个参数相当于浏览器内，通过 <strong>Ctrl + 鼠标滚轮</strong> 操作将页面放大为 200% 的视图，确保截图能截出两倍的尺寸大小。</p><p>同时，为页面内的 <code>window.devicePixelRatio</code> 设置为 2，这里是为了让 ECharts 在 Canvas 内绘制两倍像素的图表，否则截取出来的 Canvas 仍是模糊不清的大图而已。</p><p>最后，将检测到的 Canvas 坐标和尺寸乘以 2，就能截取出需要的两倍像素高清素材了。</p><p>如果需要截取 3 倍的，修改相关参数即可。</p><h2 id="Headless-Chrome"><a href="#Headless-Chrome" class="headerlink" title="Headless Chrome"></a>Headless Chrome</h2><p>就在我们完成这个项目，部署运行的第二天，我们看到了一条新闻：<strong>PhantomJS 开发者宣布“中止”项目开发</strong>。</p><p>现有的项目仍然是可以运行的，但若是日后发现其它问题，或者有严重漏洞的情况，可能还是需要使用新的方案来替代它。</p><p>通过网上搜索这个话题，发现一个很好的替代方案——谷歌推出的 Puppeteer。</p><p>可以在 node.js 环境下很方便的调用 Headless 也就是无 UI 的 Chrome。</p><p>然后通过调用它提供的 API，就能实现相同的图表截图需求。不过需要对原有的截图脚本进行相应改动和调整。</p><p>对于高分屏的截图方案甚至更简单，直接调用 <code>page.setViewport</code> 或 <code>page.emulate</code> 模拟高分屏的 <strong>viewport</strong> 即可。</p><p>如果页面内有 <strong>alert</strong> 可能会阻塞页面加载，导致无法完成截图操作。</p><p>这个情况一般进行监听后，对 <strong>dialog</strong> 做关闭操作即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">page.on(<span class="string">'dialog'</span>, <span class="keyword">async</span> dialog =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Dialog:\n'</span>, dialog.message());</span><br><span class="line">    <span class="keyword">await</span> dialog.dismiss();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其它具体 API 和操作方法，参考官方示例和文档即可：<a href="https://www.npmjs.com/package/puppeteer" target="_blank" rel="noopener">Puppeteer</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据上一篇文章已经可以实现报表邮件系统的初步 DEMO 了，但其实只是提供了基本的思路。&lt;/p&gt;
&lt;p&gt;实际部署过程中，还会遇到各种各样问题，我在这一篇内一起记录下来，希望能对大家真正地有所帮助。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://blog.krimeshu.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://blog.krimeshu.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="PhantomJS" scheme="http://blog.krimeshu.com/tags/PhantomJS/"/>
    
      <category term="邮件" scheme="http://blog.krimeshu.com/tags/%E9%82%AE%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>用 PhantomJS 让邮件报表图文并茂（一）</title>
    <link href="http://blog.krimeshu.com/2018/04/08/colorful-chart-mail-report-with-phantomjs/"/>
    <id>http://blog.krimeshu.com/2018/04/08/colorful-chart-mail-report-with-phantomjs/</id>
    <published>2018-04-07T16:00:00.000Z</published>
    <updated>2020-08-01T08:52:55.419Z</updated>
    
    <content type="html"><![CDATA[<p>在部门日常业务中，每天都会产生各种各样的数据。为了让抽象的数据，更加调理方便人阅读，就需要将数据整理成表格、图表等形式，以更生动的面貌展示在人们眼前。</p><a id="more"></a><p>通常 <strong>Web</strong> 端可以采用 <strong>ECharts</strong> 等方案来实现丰富的图表效果，但报表邮件由于各种邮件客户端环境的关系，虽然是使用 <strong>HTML</strong> 编写邮件内容，可用的样式、布局都有会诸多限制，甚至不允许执行 <strong>JavaScript</strong> 脚本。</p><p>传统报表邮件中，只能以简单的 <strong>table</strong> 表格来展示数据，一但数据维度增加、业务日渐复杂，报表邮件将变得越来越冗杂、难以理解。</p><p>那么有没有什么办法，让邮件也能实现图文并茂的图表呢？</p><h2 id="将图表转换为图片"><a href="#将图表转换为图片" class="headerlink" title="将图表转换为图片"></a>将图表转换为图片</h2><p>虽然邮件不支持脚本生成的 canvas 图表，但却是支持图片展示的。</p><p>那么只要能将图表截取为图片添加回邮件内，就能在邮件客户端里看到了，这就是我们要做的第一步。canvas 已经提供了 toDataURL 的方法，可以将画布内容转换成 img 能显示的 DataURL。</p><p>所以将网页内的 canvas 内容都提取出来，放到相同大小的 img 标签内，替换掉原本文档流中的 canvas，这样在邮件客户端内就能看到图表内容了吧？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">'canvas'</span>)</span><br><span class="line">    .forEach(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line">        img.className = canvas.className;</span><br><span class="line">        <span class="comment">// img.style.cssText = canvas.style.cssText;</span></span><br><span class="line">        <span class="keyword">var</span> cssText = canvas.getAttribute(<span class="string">'style'</span>);</span><br><span class="line">        img.setAttribute(<span class="string">'style'</span>, cssText);</span><br><span class="line">        img.width = canvas.width;</span><br><span class="line">        img.height = canvas.height;</span><br><span class="line"></span><br><span class="line">        img.src = canvas.toDataURL();</span><br><span class="line"></span><br><span class="line">        canvas.parentElement.insertBefore(img, canvas);</span><br><span class="line">        canvas.parentElement.removeChild(canvas);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>打开图表页面，在控制台执行这段脚本后，页面里的所有 canvas 都被替换成了静态截图。</p><p>需要注意，很多图表库可能会有“启动/展开动画”，在这段动画完成前截图，得到的并不是我们想要的效果。</p><p>所以还需要给这段截图脚本加个延时处理，在所有图表完全展示后在进行截图。我们一般简单设定个2-3秒即可。</p><p>对于一些具有交互效果的图表（如鼠标 hover 时展示数值），由于变成了静态图，这些交互都会消失。</p><p>所以一些关键数据，需要改为默认显示，不需要通过交互触发，以便脚本截图时能截取到。</p><h2 id="phantomJS-脚本实现"><a href="#phantomJS-脚本实现" class="headerlink" title="phantomJS 脚本实现"></a>phantomJS 脚本实现</h2><p>基本思路出来了，那么如何把它运用在我们生成报表邮件的服务器上呢？</p><p>使用 <strong>PHPMailer</strong> 和 <strong>nodemailer</strong> 等组件发送邮件时，都是提供一个本地路径作为附件参数。组件发送邮件时从本地文件中读取并发送。</p><p>所以我们对图表的截图需要保存在本地，这里不方便通过页面内部脚本实现，我们可以借助 <strong>phantomJS</strong> 的截图 API。</p><p><strong>phantomJS</strong> 脚本中可以这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> page = <span class="built_in">require</span>(<span class="string">'webpage'</span>).create();</span><br><span class="line"><span class="keyword">var</span> system = <span class="built_in">require</span>(<span class="string">'system'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可改为外部传参</span></span><br><span class="line"><span class="keyword">var</span> outputDir = <span class="string">'.'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将页面内的 canvas 保存为图片</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">saveCanvasAsImage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 检测页面中所有 canvas 的位置</span></span><br><span class="line">    <span class="keyword">var</span> _canvasArr = page.evaluate(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> canvasArr = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> canvasList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'canvas'</span>);</span><br><span class="line">        [].forEach.call(canvasList, <span class="function"><span class="keyword">function</span> (<span class="params">canvas, idx</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> name = <span class="string">'attach_'</span> + idx + <span class="string">'.png'</span>;</span><br><span class="line">            canvas.setAttribute(<span class="string">'data-image-file-name'</span>, name);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> rect = canvas.getBoundingClientRect();</span><br><span class="line">            canvasArr.push(&#123;</span><br><span class="line">                name: name,</span><br><span class="line">                top: rect.top,</span><br><span class="line">                left: rect.left,</span><br><span class="line">                width: rect.width,</span><br><span class="line">                height: rect.height</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> canvasArr;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对检测到的 canvas 进行截图</span></span><br><span class="line">    _canvasArr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">canvasInfo</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> name = canvasInfo.name;</span><br><span class="line"></span><br><span class="line">        page.clipRect = canvasInfo;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            page.render(outputDir + <span class="string">'/'</span> + name, &#123;</span><br><span class="line">                format: <span class="string">'png'</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">            <span class="built_in">console</span>.error(<span class="string">'canvas 截图失败：'</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存附件列表，供发邮件侧查询</span></span><br><span class="line">    <span class="keyword">var</span> filePath = outputDir + <span class="string">'/data-mail-attach-image.list'</span>;</span><br><span class="line">    <span class="keyword">var</span> fileContent = _canvasArr.map(<span class="function"><span class="keyword">function</span> (<span class="params">canvasInfo</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> canvasInfo.name;</span><br><span class="line">    &#125;).join(<span class="string">'\n'</span>);</span><br><span class="line"></span><br><span class="line">    fs.write(filePath, fileContent, <span class="string">'w'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>邮件内的附件会有一个 <strong>cid</strong> 标记，我们这边约定好，发送邮件时的 <strong>cid</strong> 使用刚才保存到 <strong>data-mail-attach-image.list</strong> 内的图片文件名即可。</p><p>需要注意的是，<strong>phantomJS</strong> 的 <strong>webkit</strong> 内核可能过旧，<strong>querySelectorAll</strong> 返回的 <strong>dom list</strong> 没有 <strong>forEach</strong> 函数的话，需要通过 <strong>[].forEach.call</strong> 来实现。</p><p>接下来则是将 <strong>canvas</strong> 替换为使用 <strong>cid</strong> 标记附件资源的 <strong>img</strong> 标签：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用附件图片替换 canvas</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceCanvasWithImage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    page.evaluate(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> canvasList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'canvas'</span>);</span><br><span class="line">        [].forEach.call(canvasList, <span class="function"><span class="keyword">function</span> (<span class="params">canvas</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> imageFileName = canvas.getAttribute(<span class="string">'data-image-file-name'</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line">            img.className = canvas.className;</span><br><span class="line">            <span class="comment">// img.style.cssText = canvas.style.cssText;</span></span><br><span class="line">            <span class="keyword">var</span> cssText = canvas.getAttribute(<span class="string">'style'</span>);</span><br><span class="line">            img.setAttribute(<span class="string">'style'</span>, cssText);</span><br><span class="line">            img.width = canvas.width;</span><br><span class="line">            img.height = canvas.height;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// img.src = canvas.toDataURL();</span></span><br><span class="line">            img.src = <span class="string">'cid: '</span> + imageFileName;</span><br><span class="line"></span><br><span class="line">            canvas.parentElement.insertBefore(img, canvas);</span><br><span class="line">            canvas.parentElement.removeChild(canvas);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，做好清理页面脚本等收尾工作，将最终的页面 <strong>dom</strong> 转为 <strong>html</strong> 即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 收尾并保存 html</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tailInWorkAndSaveHtml</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 清理邮件客户端内无效的 script 标签</span></span><br><span class="line">    page.evaluate(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> scriptList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'script'</span>);</span><br><span class="line">        [].forEach.call(scriptList, <span class="function"><span class="keyword">function</span> (<span class="params">script</span>) </span>&#123;</span><br><span class="line">            script.parentElement.removeChild(script);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取页面的 outterHTML，添加 DOCTYPE 后保存为 html 文件，作为邮件内容</span></span><br><span class="line">    <span class="keyword">var</span> html = page.evaluate(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">document</span>.documentElement.outerHTML;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> filePath = outputDir + <span class="string">'/data-mail.html'</span>;</span><br><span class="line">    <span class="keyword">var</span> fileContent = <span class="string">'&lt;!DOCTYPE html&gt;\n'</span> + html;</span><br><span class="line"></span><br><span class="line">    fs.write(filePath, fileContent, <span class="string">'w'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跑完整个流程的逻辑的入口：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">exit</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Mail render done.'</span>);</span><br><span class="line">    phantom.exit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始工作</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">work</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 从参数中取需要处理的页面路径</span></span><br><span class="line">    <span class="keyword">var</span> filePath = fs.absolute(outputDir + <span class="string">'/'</span> + system.args[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    page.open(filePath, <span class="function"><span class="keyword">function</span> (<span class="params">status</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 检查页面是否正常加载完毕</span></span><br><span class="line">        <span class="keyword">if</span> (status !== <span class="string">'success'</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.error(<span class="string">'Mail render error: '</span> + status);</span><br><span class="line">            exit();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 2.5 秒后开始对图表截图</span></span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                saveCanvasAsImage();</span><br><span class="line">                replaceCanvasWithImage();</span><br><span class="line">                tailInWorkAndSaveHtml();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">'Mail render error:'</span>);</span><br><span class="line">                <span class="built_in">console</span>.error(ex);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                exit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">2500</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h2><p>将上述脚本保存为 <strong>mail-render.js</strong>，通过将报表数据转为 <strong>ECharts</strong> 等前端图标库实现的页面后（如保存在本地，路径为：<strong>./report_20180408.html</strong>），通过服务器环境执行这段 <strong>shell</strong> 脚本：<code>phantomjs mail-render.js ./report_20180408.html</code>。</p><p>然后将生成的 <strong>data-mail.html</strong> 作为邮件内容，<strong>data-mail-attach-image.list</strong> 内的图片作为附件，调用 <strong>PHPMailer/nodemailer</strong> 发送邮件即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在部门日常业务中，每天都会产生各种各样的数据。为了让抽象的数据，更加调理方便人阅读，就需要将数据整理成表格、图表等形式，以更生动的面貌展示在人们眼前。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://blog.krimeshu.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://blog.krimeshu.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="PhantomJS" scheme="http://blog.krimeshu.com/tags/PhantomJS/"/>
    
      <category term="邮件" scheme="http://blog.krimeshu.com/tags/%E9%82%AE%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>由重构进阶前端开发入门 (四) 面向对象</title>
    <link href="http://blog.krimeshu.com/2018/01/31/basic-knowledge-points-for-beginner-3/"/>
    <id>http://blog.krimeshu.com/2018/01/31/basic-knowledge-points-for-beginner-3/</id>
    <published>2018-01-30T16:00:00.000Z</published>
    <updated>2020-08-01T08:52:55.417Z</updated>
    
    <content type="html"><![CDATA[<p>了解了在浏览器环境下，使用 JS 编程的基础概念之后，开始思考如何组织优化自己的代码，从编程技巧上提升开发和维护工作的效率吧。</p><a id="more"></a><blockquote><p>相关文章：</p><a href="/2017/05/04/basic-knowledge-points-for-beginner/" title="由重构进阶前端开发入门 (一) DOM 操作">由重构进阶前端开发入门 (一) DOM 操作</a><a href="/2017/08/24/basic-knowledge-points-for-beginner-1/" title="由重构进阶前端开发入门 (二) 事件与事件对象">由重构进阶前端开发入门 (二) 事件与事件对象</a><a href="/2017/10/25/basic-knowledge-points-for-beginner-2/" title="由重构进阶前端开发入门 (三) 事件冒泡与事件代理">由重构进阶前端开发入门 (三) 事件冒泡与事件代理</a></blockquote><h1 id="四-面向对象"><a href="#四-面向对象" class="headerlink" title="(四) 面向对象"></a>(四) 面向对象</h1><h2 id="DRY-Don’t-Repeat-Yourself-原则"><a href="#DRY-Don’t-Repeat-Yourself-原则" class="headerlink" title="DRY (Don’t Repeat Yourself) 原则"></a>DRY (Don’t Repeat Yourself) 原则</h2><p>JavaScript 是一门编程语言，和其它计算机语言一样，在你编码的过程中需要有避免重复代码和逻辑的意识，注意不断优化自己的代码。</p><p>以免写出看似体系庞大而可靠，实则冗余且迟滞的代码，埋下 bug 隐患，影响团队伙伴阅读代码、协作开发的效率，也耽误自己以后优化和迭代项目。</p><p>因此，其中重要的原则之一就是 <strong>DRY (Don’t Repeat Yourself)</strong> 原则。</p><p>当你第一次写下某段代码，之后在另一个地方又写下或粘贴同样的代码，你就应该有需要消除和提取重复代码的冲动了。</p><p>等到第三次，再另一个地方又出现同样的代码时，就可以考虑行动起来，提取共用的代码而不是又重复一遍。</p><h2 id="函数复用、公用库"><a href="#函数复用、公用库" class="headerlink" title="函数复用、公用库"></a>函数复用、公用库</h2><p>最基本的方法，就是把重复代码提取成复用的函数。</p><h3 id="对话框展示函数"><a href="#对话框展示函数" class="headerlink" title="对话框展示函数"></a>对话框展示函数</h3><p>例如，在页面某处有一个弹出 Dialog 的逻辑，写下了这样的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $dialog1 = $(<span class="string">'&lt;div class="dialog-box"&gt;'</span> + </span><br><span class="line">                 <span class="string">'  &lt;p class="dialog-msg"&gt;&lt;/p&gt;'</span> +</span><br><span class="line">                 <span class="string">'  &lt;a class="dialog-btn" close-dialog&gt;确定&lt;/a&gt;'</span> + </span><br><span class="line">                 <span class="string">'&lt;/div&gt;'</span>)</span><br><span class="line">                .on(<span class="string">'click'</span>,<span class="string">'[close-dialog]'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                  $(<span class="keyword">this</span>).closest(<span class="string">'.dialog-box'</span>).hide();</span><br><span class="line">                &#125;)</span><br><span class="line">                .find(<span class="string">'.dialog-msg'</span>)</span><br><span class="line">                .text(<span class="string">'登陆成功！'</span>);</span><br><span class="line">$(<span class="string">'body'</span>).append($dialog1);</span><br></pre></td></tr></table></figure><p>之后又增加了一个类似的 Toast 消息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $dialog2 = $(<span class="string">'&lt;div class="dialog-box"&gt;'</span> + </span><br><span class="line">                 <span class="string">'  &lt;p class="dialog-msg"&gt;&lt;/p&gt;'</span> +</span><br><span class="line">                 <span class="string">'  &lt;a class="dialog-btn" close-dialog&gt;确定&lt;/a&gt;'</span> + </span><br><span class="line">                 <span class="string">'&lt;/div&gt;'</span>)</span><br><span class="line">                .on(<span class="string">'click'</span>, <span class="string">'[close-dialog]'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                  $(<span class="keyword">this</span>).closest(<span class="string">'.dialog-box'</span>).hide();</span><br><span class="line">                &#125;)</span><br><span class="line">                .find(<span class="string">'.dialog-msg'</span>)</span><br><span class="line">                .text(<span class="string">'评论发送失败！'</span>);</span><br><span class="line">$(<span class="string">'body'</span>).append($dialog2);</span><br></pre></td></tr></table></figure><p>这段代码与上面那段几乎所是相同的，区别只在于提示语。</p><p>明显没必要这样重复，可以提取出一个通用的兑换框展示函数 <strong>showDialog</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showDialog</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $dialog = $(<span class="string">'&lt;div class="dialog-box"&gt;'</span> + </span><br><span class="line">                  <span class="string">'  &lt;p class="dialog-msg"&gt;&lt;/p&gt;'</span> +</span><br><span class="line">                  <span class="string">'  &lt;a class="dialog-btn" close-dialog&gt;确定&lt;/a&gt;'</span> + </span><br><span class="line">                  <span class="string">'&lt;/div&gt;'</span>)</span><br><span class="line">                  .on(<span class="string">'click'</span>, <span class="string">'[close-dialog]'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    $(<span class="keyword">this</span>).closest(<span class="string">'.dialog-box'</span>).hide();</span><br><span class="line">                  &#125;)</span><br><span class="line">                  .find(<span class="string">'.dialog-msg'</span>)</span><br><span class="line">                  .text(msg);</span><br><span class="line">  $(<span class="string">'body'</span>).append($dialog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showDialog(<span class="string">'登陆成功！'</span>);</span><br><span class="line"></span><br><span class="line">showDialog(<span class="string">'评论发送失败！'</span>);</span><br></pre></td></tr></table></figure><p>提取<strong>共用函数</strong>可以说是最基本的编程思想了。</p><p>这样之后需要增加新的消息，或是对原有的所有提示消息做调整和修复时，不需要修改散落在四处的代码，只需修改一处，效率大大提升。</p><p>有一些代码甚至不止可以用于一个项目，还可以在今后的项目开发中继续复用，这些函数逻辑可以提取成<strong>公用代码库</strong>，节省今后项目开发的时间。</p><h2 id="抽象成对象-类"><a href="#抽象成对象-类" class="headerlink" title="抽象成对象/类"></a>抽象成对象/类</h2><p>上面的思想概括起来，其实就是将处理一类事务的过程，以函数的形式复用。</p><p>是一种相对初级的复用思想，随着业务逻辑逐渐复杂，这种办法的效果也越来越弱。</p><p>结果就是，这样写出来的 js 文件，到达一定规模之后，其中虽然没什么重复代码，但却有着几十上百个函数。阅读者理清其中的顺序和关系会很耗时，难以保证可读性。</p><p>而且函数形式的复用，并不能很好的处理带属性、状态一类的情况。</p><p>比如上面的对话框函数，如果要给对话框增加拖动的处理函数，还要在记录坐标、层级、打开状态等等属性时，需要手动从外部传入很多变量来处理。</p><p>导致原本是对话框相关的逻辑和数据，却被分散到了文件内的不同地方，需要做属性增减时很难集中调整。</p><p>继续增加函数形式的控制逻辑，也容易与其他函数混在一起。项目合作的同事稍不注意，就容易插入其他函数把它们打散。</p><p>最后赶出来的项目或许能正常运行，但内部代码却是互相穿插、混乱不堪的<strong>意大利面条代码</strong>，几乎无法维护。</p><p>所以计算机软件工程的前人们，探索出了<strong>面向对象</strong>的编程思想。</p><h3 id="对话框类的定义"><a href="#对话框类的定义" class="headerlink" title="对话框类的定义"></a>对话框类的定义</h3><p>让我们从头想想，<strong>对话框</strong>是什么呢？</p><p>它应该是具有特定坐标、宽高、背景色等样式，可以设定其内容、坐标、控制按键等属性的绝对定位的特定元素。</p><p>那么有没有这样一种办法，使我们可以在需要使用对话框时，做到：</p><ul><li>简单快速地创建对话框；</li><li>调用API就可以调整内容、移动、展示、收起对话框；</li><li>并且使不同对话框操作接口一致，自身数据却互不干扰；</li><li>有必要时，还可以在原有接口基础上快速增加新的特性呢？</li></ul><p>刚才我们提到的这些，可以通过面向对象的<strong>继承、封装</strong>和<strong>多态</strong>来实现。</p><p>不过由于 JavaScript 的特殊性，<strong>多态</strong>在鸭子模式下的体现并不明显，暂且不提。先从一些基本概念开始说起。</p><p>上一步里，我们抽象出了对话框的基本概念，也就是我们需要的<strong>对话框</strong>大致上是个什么的东西。</p><p>运用面向对象的思想，我们可以把它们作为其成员属性、方法，来定义出一个<strong>对话框类</strong>。</p><p>为了方便新同学直接在浏览器里测试代码，这里采用 ES5 的类写法举例：</p><blockquote><p>关于 JavaScript 的原型链和面相对象的关系，本文暂不深入说明，以免初学者混淆。</p><p>大家可以先学会运用现有的方式，先知其然后知其所以然，通过实践记忆之后再深入了解原理也会更容易上手。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对话框类的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dialog</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// 创建相应 dom，记录到当前构建的对象内</span></span><br><span class="line">  <span class="keyword">this</span>.$dom = $(<span class="string">'&lt;div class="dialog-box"&gt;'</span> + </span><br><span class="line">                <span class="string">'  &lt;p class="dialog-msg"&gt;&lt;/p&gt;'</span> +</span><br><span class="line">                <span class="string">'  &lt;a class="dialog-btn" close-dialog&gt;确定&lt;/a&gt;'</span> + </span><br><span class="line">                <span class="string">'&lt;/div&gt;'</span>)</span><br><span class="line">                .on(<span class="string">'click'</span>, <span class="string">'[close-dialog]'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                  self.hide();</span><br><span class="line">                &#125;);</span><br><span class="line">  $(<span class="string">'body'</span>).append(<span class="keyword">this</span>.$dom);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对话框的可用方法</span></span><br><span class="line">Dialog.prototype = &#123;</span><br><span class="line">  <span class="comment">// 记录构造函数</span></span><br><span class="line">  <span class="keyword">constructor</span>: Dialog,</span><br><span class="line">  // 设置内容</span><br><span class="line">  setContent: function (content) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$dom.find(<span class="string">'.dialog-msg'</span>).text(content);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 展示对话框</span></span><br><span class="line">  show: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.$dom.show();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 收起对话框</span></span><br><span class="line">  hide: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.$dom.hide();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先声明对话框类 <strong>Dialog</strong> 的构造函数，之后每个对话框都将通过这个函数构建出具体的实例。</p><p>其中通过操作 <strong>this</strong>，可以使所有对话框都有 DOM 对象可供操作，且互相独立不受干扰（比如对话框1和对话框2都具有 <strong>$dom</strong> 的属性，修改对话框1的 <strong>$dom</strong> 时，对话框2的 <strong>$dom</strong> 不会受到任何影响，反之亦然）。</p><p>然后，增加了几个 <strong>Dialog</strong> 原型函数 <strong>show, hide, destroy</strong>。这几个函数被称为类的<strong>方法</strong>。</p><p>所有对话框都可以调用这些方法，与构造函数一样，其中也可以操作 <strong>this</strong> 来达成不同实例互不干扰的效果。</p><h3 id="对话框实例"><a href="#对话框实例" class="headerlink" title="对话框实例"></a>对话框实例</h3><p>完成了最基本的可复用对话框类的创建，只需要通过 new 就可以实例化后使用了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建对话框1</span></span><br><span class="line"><span class="keyword">var</span> dialog1 = <span class="keyword">new</span> Dialog();</span><br><span class="line"><span class="comment">// 设置其内容</span></span><br><span class="line">dialog1.setContent(<span class="string">'登陆成功！'</span>);</span><br><span class="line"><span class="comment">// 展示对话框1</span></span><br><span class="line">dialog1.show();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对话框2</span></span><br><span class="line"><span class="keyword">var</span> dialog2 = <span class="keyword">new</span> Dialog();</span><br><span class="line"><span class="comment">// 设置其内容（不影响对话框1）</span></span><br><span class="line">dialog2.setContent(<span class="string">'评论发送失败！'</span>);</span><br><span class="line"><span class="comment">// 展示对话框2</span></span><br><span class="line">dialog2.show();</span><br><span class="line"><span class="comment">// 3秒后自动收起（同样不影响对话框1）</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  dialog2.hide();</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>与 <strong>showDialog</strong> 函数相比，这样写有什么优势呢？</p><p>首先是逻辑和属性集中化，方便对同一类的成员进行维护和扩展。</p><p>通过 <strong>this</strong> 操作每个实例，避免重复的传参，无需手动区分不同实例，灵活又便捷。</p><p>而且通过 <strong>IDE</strong> 的解析推断，可以根据对象所属的类型，自动给出属性和方法的智能提示，提升开发效率，避免在函数海中苦苦搜寻，甚至混淆调用。</p><p>目前主流的前端自动化都有脚本打包功能，根据类和基本逻辑划分项目文件结构后，维护起来十分清晰便利。</p><p>合作开发的同事可以通过查看项目结构，对于流程有个大致概念。</p><p>对于顶层逻辑只需要了解主要流程，底层逻辑都被封装入类内对外透明。</p><p>每个文件内只需要处理自身相关的逻辑，代码量基本可以控制在400行内，属于最适合维护阅读的程度。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>有其他语言的面向对象开发经验的同学，可能会对 JavaScript 内的类生命写法不解，为什么看起来会这么奇怪。</p><p>这是因为 JavaScript 的面向对象是基于原型而非基于类来实现的。</p><p>最直观的区别就是其实并不存在真正的类，而是基于对象实例，通过将实例作为构造函数的原型，再通过调用构造函数来产生继承于此的新对象。</p><p>这种模式非常灵活，适合 JavaScript 动态脚本语言的开发模式。</p><p>但对于新手来说可能会更难理解，实际操作中实现较完美的继承扩展，区分原型和实例的函数也有一定难度，容易造成误解和混淆。</p><p>所以 ES6 中提供了更方便的 class 定义方式，目前主流的前端开发框架 React、Vue、Angluar 也都推荐使用 ES6 的新写法。</p><p>大家编写 ES5 的模拟类体验和理解后，再通过这些框架的脚手架或者 babel 的 repl 感受 ES6 中定义类的便捷性。</p><p>有兴趣的话，可以尝试使用 ES6 再实现上面 dialog 的例子，并扩展出宽高、坐标属性，和对应的调整大小、位置的函数，作为这一期的课后练习吧~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解了在浏览器环境下，使用 JS 编程的基础概念之后，开始思考如何组织优化自己的代码，从编程技巧上提升开发和维护工作的效率吧。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://blog.krimeshu.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://blog.krimeshu.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="初学者" scheme="http://blog.krimeshu.com/tags/%E5%88%9D%E5%AD%A6%E8%80%85/"/>
    
      <category term="面向对象" scheme="http://blog.krimeshu.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>由重构进阶前端开发入门 (三) 事件冒泡与事件代理</title>
    <link href="http://blog.krimeshu.com/2017/10/25/basic-knowledge-points-for-beginner-2/"/>
    <id>http://blog.krimeshu.com/2017/10/25/basic-knowledge-points-for-beginner-2/</id>
    <published>2017-10-24T16:00:00.000Z</published>
    <updated>2020-08-01T08:52:55.415Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇章中，我们掌握了页面事件的基本操作，这次学习事件 API 的进阶和拓展用法了。</p><a id="more"></a><blockquote><p>相关文章：</p><a href="/2017/05/04/basic-knowledge-points-for-beginner/" title="由重构进阶前端开发入门 (一) DOM 操作">由重构进阶前端开发入门 (一) DOM 操作</a><a href="/2017/08/24/basic-knowledge-points-for-beginner-1/" title="由重构进阶前端开发入门 (二) 事件与事件对象">由重构进阶前端开发入门 (二) 事件与事件对象</a></blockquote><h1 id="三-事件冒泡与事件代理"><a href="#三-事件冒泡与事件代理" class="headerlink" title="(三) 事件冒泡与事件代理"></a>(三) 事件冒泡与事件代理</h1><h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><p>假设你需要实现这样的效果：用户登录状态过期了，点击页面内任何按键都给出提示；或者右上角提示通知消息时，点击页面内任何元素后折叠通知消息。</p><p>这两种情况下，你会把点击事件的监听器绑定到哪些元素上呢？</p><p>把页面所有按键、甚至所有页面元素都绑定一遍？——你肯定是开玩笑的对吧，这么做勉强能达到想要的效果，但未免也太暴力，性能太低、可维护性也太差了。</p><p>且不说绑定如此多元素的监听器的效率，一旦页面里的元素有变动、或者状态变更后需要解除绑定，都得做各种额外零散的补救操作。这样的代码可以说没法应对业务的任何变更，几乎能逼死之后的维护人员。</p><p>正确姿势其实很简单。</p><p>当年浏览器事件模型已经帮我们考虑到了这种情况，提供了“事件冒泡”这一机制。</p><p>由于页面内元素是层级嵌套的。当你点击某个按键时，也可以说是点击了它所在的父元素中的某个位置。由此类推，层层递进，就相当于点击了整个 html 文档的某处。</p><img src="/images/basic-knowledge-points-for-beginner/popup.png" title="popup"><p>因此点击事件会从事件发生的最底层元素开始，自动一层层往上走，不出意外，会一直触发到页面的最外层。</p><p>所以，我们只需要在 <strong>body</strong> 元素上绑定点击事件监听函数，处理完毕后清理掉即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showToast</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 展示 toast 内容</span></span><br><span class="line">  $(<span class="string">'.toast-content'</span>).text(msg).show();</span><br><span class="line">  <span class="comment">// 2. 绑定点击后关闭的事件处理函数</span></span><br><span class="line">  $(<span class="string">'body'</span>).on(<span class="string">'click'</span>, hideToast);</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">hideToast</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 3. 收起 toast 内容</span></span><br><span class="line">    $(<span class="string">'.toast-content'</span>).hide();</span><br><span class="line">    <span class="comment">// 4. 解除绑定的函数</span></span><br><span class="line">    $(<span class="string">'body'</span>).off(<span class="string">'click'</span>, hideToast);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第二篇《事件与事件对象》中，我们提到过通常名为 <code>e</code> 的事件对象参数。</p><p>它除了携带事件相关信息的各种属性之外，还有一个与事件冒泡相关的函数 <code>stopPropagation</code>。</p><p>在内部元素已经处理完事件，不需要传递到外层，以免引发其它意外情况时，可以用来阻止事件继续向上冒泡。</p><p>事件对象的 <code>target</code> 属性是触发事件的对象，可用来在外层进行甄别，决定事件的具体处理方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'.btn-login'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 点击登录按键时，就不用提示登录过期了，所以我们阻止这次点击冒泡到 body 层</span></span><br><span class="line">  e.stopPropagation();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// .btn-login 的点击事件在里层被阻止冒泡了，最外层的 body 接收不到，不会再给出过期提示</span></span><br><span class="line">$(<span class="string">'body'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 登录过期时，给出登录过期提示</span></span><br><span class="line">  alert(<span class="string">'登录过期，请重新登录后再进行操作。'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="事件默认行为"><a href="#事件默认行为" class="headerlink" title="事件默认行为"></a>事件默认行为</h2><p>上面举的例子中，提到过登陆过期时的提示信息。</p><p>但如果用户点击的是 <strong>a</strong> 标签，跳转的话就很难看见提示信息了，这种情况该怎么办呢？</p><p>这个时候可以使用事件对象的另一个函数 <code>preventDefault</code> 来阻止浏览器对各种元素的默认处理行为，比如这里的 <strong>a</strong> 标签跳转行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .btn-login 的点击事件在里层被阻止冒泡了，最外层的 body 接收不到，不会再给出过期提示</span></span><br><span class="line">$(<span class="string">'body'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 登录过期时，给出登录过期提示</span></span><br><span class="line">  alert(<span class="string">'登录过期，请重新登录后再进行操作。'</span>);</span><br><span class="line">  e.preventDefault();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h2><p>上面的例子还是比较简单的，实际业务中需要对业务状态、点击的具体元素进行筛选判断才行。</p><p>这时候就得用到事件对象里的 <code>target</code> 属性了，通过 <strong>jQuery</strong> 对象的 <code>is</code>、<code>closest</code> 等函数即可做具体的判断：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .btn-login 的点击事件在里层被阻止冒泡了，最外层的 body 接收不到，不会再给出过期提示</span></span><br><span class="line">$(<span class="string">'body'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 登录过期时，点击的元素带有 need-login 特性的话，统一给出登录过期提示</span></span><br><span class="line">  <span class="comment">// (如：`&lt;button need-login="true"&gt;编辑内容&lt;/button&gt;`)</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.LOGIN_STATE === <span class="string">'expired'</span> &amp;&amp; </span><br><span class="line">     $(e.target).is(<span class="string">'[need-login="true"]'</span>)) &#123;</span><br><span class="line">    alert(<span class="string">'登录过期，请重新登录后再进行操作。'</span>);</span><br><span class="line">    e.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样将事件监听函数加到父元素上，借助事件冒泡机制来处理数目不定的子元素事件的方式，就被叫做<strong>事件代理</strong>（或<strong>事件委托</strong>）。</p><p>除了上述情况，实际业务中可能还会遇到需要处理动态增减的数据，对上百上千的数据条目提供点击处理，都是通过这样绑定父元素做<strong>事件代理</strong>来处理的。</p><p><strong>jQuery</strong> 的 <strong>on</strong> 函数还提供了更快捷的绑定方式，直接在绑定的时候增加一个筛选的选择器即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'body'</span>).on(<span class="string">'click'</span>, <span class="string">'[need-login="true"]'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 登录过期时，点击的元素带有 need-login 特性的话，统一给出登录过期提示</span></span><br><span class="line">  <span class="comment">// (如：`&lt;button need-login="true"&gt;编辑内容&lt;/button&gt;`)</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.LOGIN_STATE === <span class="string">'expired'</span>) &#123;</span><br><span class="line">    alert(<span class="string">'登录过期，请重新登录后再进行操作。'</span>);</span><br><span class="line">    e.preventDefault();</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇章中，我们掌握了页面事件的基本操作，这次学习事件 API 的进阶和拓展用法了。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://blog.krimeshu.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://blog.krimeshu.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="初学者" scheme="http://blog.krimeshu.com/tags/%E5%88%9D%E5%AD%A6%E8%80%85/"/>
    
      <category term="事件" scheme="http://blog.krimeshu.com/tags/%E4%BA%8B%E4%BB%B6/"/>
    
      <category term="冒泡" scheme="http://blog.krimeshu.com/tags/%E5%86%92%E6%B3%A1/"/>
    
      <category term="代理" scheme="http://blog.krimeshu.com/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>由重构进阶前端开发入门 (二) 事件与事件对象</title>
    <link href="http://blog.krimeshu.com/2017/08/24/basic-knowledge-points-for-beginner-1/"/>
    <id>http://blog.krimeshu.com/2017/08/24/basic-knowledge-points-for-beginner-1/</id>
    <published>2017-08-23T16:00:00.000Z</published>
    <updated>2020-08-01T08:52:55.415Z</updated>
    
    <content type="html"><![CDATA[<p>掌握 DOM 的基本概念后，这次我们讲讲浏览器的事件和事件对象。再结合具体业务需求，通过例子展示事件相关的操作方法。</p><a id="more"></a><blockquote><p>相关文章：</p><a href="/2017/05/04/basic-knowledge-points-for-beginner/" title="由重构进阶前端开发入门 (一) DOM 操作">由重构进阶前端开发入门 (一) DOM 操作</a></blockquote><h1 id="事件与事件对象"><a href="#事件与事件对象" class="headerlink" title="事件与事件对象"></a>事件与事件对象</h1><h2 id="事件与-DOM"><a href="#事件与-DOM" class="headerlink" title="事件与 DOM"></a>事件与 DOM</h2><h3 id="1-从最初的“点击”开始"><a href="#1-从最初的“点击”开始" class="headerlink" title="1. 从最初的“点击”开始"></a>1. 从最初的“点击”开始</h3><blockquote><p>“点击这个按键时，XXX 变成 YYY，然后……”</p></blockquote><p>新手最初学会的，基本是这样使用 <code>onclick</code> 事件属性进行处理：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"alert('Hello world!')"</span>&gt;</span>Button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者对复杂些的处理，绑定全局函数：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"txt_info"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"updateInfo"</span>&gt;</span>Button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">updateInfo</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">'txt_info'</span>).textContent = <span class="keyword">new</span> <span class="built_in">Date</span>().toString();</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-新的处理方式"><a href="#2-新的处理方式" class="headerlink" title="2. 新的处理方式"></a>2. 新的处理方式</h3><p>网上古老的 JS 入门教程可能都是这么写的。<br>不过，二十年来业务不断进化，这样的处理方式虽然还被浏览器所支持，但暴露出越来越多问题，已经不再建议使用了。</p><p>一是这种方式只能绑定一个处理函数，且不能取消绑定不够灵活；二是全局函数容易混淆，项目到达一定规模后容易失控，导致意外。</p><p>W3C 标准推荐使用 DOM 对象的 <code>addEventListener</code> 和 <code>removeEventListener</code> 方法来绑定和取消绑定处理函数。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"txt_info"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn_update"</span>&gt;</span>Button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">'btn_update'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">'txt_info'</span>).textContent = <span class="keyword">new</span> <span class="built_in">Date</span>().toString();</span></span><br><span class="line"><span class="javascript">    &#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>低版本 IE 浏览器使用了自家的另一套事件相关方法，已经随着浏览器标准迭代被废弃，这里不再赘述。</p><p>不过日常需要对 IE8 这一类浏览器进行支持时，一般使用 jQuery 等现成做好了兼容性处理的框架，使用方便快捷，API 也是一目了然，非常容易理解。</p><p>上述代码在使用 jQuery 的时候可以写作：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"txt_info"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn_update"</span>&gt;</span>Button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    $(<span class="string">'#btn_update'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        $(<span class="string">'#txt_info'</span>).text(<span class="keyword">new</span> <span class="built_in">Date</span>().toString());</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-DOM-对象与-jQuery-对象"><a href="#3-DOM-对象与-jQuery-对象" class="headerlink" title="3. DOM 对象与 jQuery 对象"></a>3. DOM 对象与 jQuery 对象</h3><p>上面 jQuery 的代码和之前的原生 JS 代码等效，但有一点需要注意，也是新手经常混淆的。</p><p><code>$(&#39;&lt;css选择器&gt;&#39;)</code> 的效果是根据 CSS 选择器找到页面上对应的元素，返回的对象可以对其做绑定事件处理器等操作，如上面的 <code>$.fn.on</code> (即 <code>$(...).on</code>)。</p><p>但是仔细观察这个返回对象，你会发现它并不是原生的 DOM 对象，对它做原生 DOM 相关的操作时会发现它并不支持原生 DOM 相关的 API。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#txt_info'</span>).textContent = <span class="keyword">new</span> <span class="built_in">Date</span>();    <span class="comment">// × - 无效</span></span><br><span class="line">$(<span class="string">'#txt_info'</span>).text(<span class="keyword">new</span> <span class="built_in">Date</span>());            <span class="comment">// √ - 有效</span></span><br></pre></td></tr></table></figure><p>它其实是一个特殊数组，里面存放着传入 CSS 选择器所对应的所有 DOM 对象，通过 <code>.length</code> 可以查看其中选中的元素数量，通过数组下标可以取出其中的原生 DOM 对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#text_info'</span>).length;                     <span class="comment">// =&gt; 1</span></span><br><span class="line">$(<span class="string">'#text_info'</span>)[<span class="number">0</span>] === </span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'text_info'</span>);   <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><p>当 jQuery 选择了多个元素时，各类 API 操作可以对立面所有成员进行处理，非常方便：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'blockquote'</span>).prepend(<span class="string">'&lt;span&gt;“&lt;/span&gt;'</span>);  <span class="comment">// 所有 blockquote 元素内容前插入 “ 符号</span></span><br></pre></td></tr></table></figure><h3 id="4-常用-jQuery-API"><a href="#4-常用-jQuery-API" class="headerlink" title="4. 常用 jQuery API"></a>4. 常用 jQuery API</h3><ul><li>选择元素和创建元素使用 <code>$()</code>, <code>find</code>, <code>filter</code></li><li>处理事件使用 <code>on</code>, <code>off</code>, <code>trigger</code></li><li>操作元素内容使用 <code>text</code>, <code>html</code></li><li>操作元素位置和尺寸使用 <code>offset</code>, <code>width</code>, <code>height</code></li><li>操作元素属性/特性使用 <code>prop</code>, <code>attr</code>, <code>removeProp</code>, <code>removeAttr</code></li><li>操作元素样式/<code>className</code> 时使用 <code>css</code>, <code>addClass</code>, <code>removeClass</code>, <code>toggleClass</code>, <code>hasClass</code></li><li>父元素插入/追加/移除子元素使用 <code>prepend</code>, <code>append</code></li><li>子元素附近插入/查找邻近元素使用 <code>prev</code>, <code>next</code>, <code>prevAll</code>, <code>nextAll</code></li><li>子元素移除时使用 <code>remove</code></li><li>查找父元素/祖先元素使用 <code>parent</code>, <code>parents</code></li></ul><p>掌握上述最常用也是最基本的 API 的使用方法和对应场景后，就可以实现 90% 以上的日常业务需求了。</p><h2 id="事件对象-e"><a href="#事件对象-e" class="headerlink" title="事件对象 e"></a>事件对象 <code>e</code></h2><p>由于原生 DOM API 写起来太过繁琐，以及兼容性的处理太过复杂，这里推荐使用 jQuery 等现成框架，业余时间再对常见的兼容性进行了解，以便遇到意外时知道问题出在何处。</p><p>当我们对页面元素绑定了事件处理器后，常常会看到一个神秘的 <code>e</code> 参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#btn_update'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Todo: ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>它就是所谓的“事件对象”了，不过上面的例子里似乎并没有用上它啊？它到底有什么作用呢？</p><p>个人理解是，“事件”就是用户操作、浏览器状态变化这些正在发生的事情；而“事件对象”就是这个“事件”发生的相关信息。</p><p>比如用户点击按键 <code>#btn_update</code> 后，触发了点击事件 <code>click</code>，事件的监听函数接收到的事件对象 <code>e</code> 就会包含这次点击的相关信息，如点击坐标、发起元素、传递路径等等。</p><p>此外，事件对象 <code>e</code> 还提供了一些 API 可以对这次事件进行一些附加操作，下面进行具体说明。</p><h3 id="例子：幻灯片切换效果（点击位置判断）"><a href="#例子：幻灯片切换效果（点击位置判断）" class="headerlink" title="例子：幻灯片切换效果（点击位置判断）"></a>例子：幻灯片切换效果（点击位置判断）</h3><p>过去对于用户点击图片区域判断，需要通过 img 元素的 usemap 属性实现，使用方式较为复杂，且限制较多，可复用性低。</p><p>现在，实现一个简单的幻灯片点击切换效果，只需根据事件对象中相关参数来判断即可。</p><p>大致效果是：用户点击左右两侧 20% 区域时，切换展示上/下一章图片；点击中间区域不处理。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.pic-list</span> &#123;</span></span><br><span class="line"><span class="undefined">        margin: 0;</span></span><br><span class="line"><span class="undefined">        padding: 0;</span></span><br><span class="line"><span class="undefined">        list-style: none;</span></span><br><span class="line"><span class="undefined">        width: 400px;</span></span><br><span class="line"><span class="undefined">        height: 300px;</span></span><br><span class="line"><span class="undefined">        overflow: hidden;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.pic-item</span> &#123;</span></span><br><span class="line"><span class="undefined">        display: none;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.pic-item</span><span class="selector-class">.current</span> &#123;</span></span><br><span class="line"><span class="undefined">        display: block;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.pic-item</span> <span class="selector-tag">img</span> &#123;</span></span><br><span class="line"><span class="undefined">        display: block;</span></span><br><span class="line"><span class="undefined">        width: 100%;</span></span><br><span class="line"><span class="undefined">        height: 100%;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"pic-list"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"pic-item current"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/1.jpg"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"pic-item"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/2.jpg"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"pic-item"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/3.jpg"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>只需要对列表元素绑定点击事件，然后根据点击位置和列表宽度，就能判断出用户点击的区域，然后做样式切换即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 选择 .pic-list 元素，绑定 click 事件监听器</span></span><br><span class="line">$(<span class="string">'.pic-list'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> $list = $(<span class="keyword">this</span>),</span><br><span class="line">        $item = $list.find(<span class="string">'.pic-item'</span>),</span><br><span class="line">        itemCount = $item.length;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 2. 获取点击坐标，列表元素坐标和列表宽度</span></span><br><span class="line">    <span class="keyword">var</span> clickPos = &#123; <span class="attr">left</span>: e.pageX, <span class="attr">top</span>: e.pageY &#125;,</span><br><span class="line">        listPos = $list.offset(),</span><br><span class="line">        listWidth = $list.width();</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 3. 点击坐标 - 列表坐标，再除以列表宽度，即可得到点击相对列表的横向位置百分比</span></span><br><span class="line">    <span class="keyword">var</span> px = (clickPos.left - listPos.left) / listWidth;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 根据点击是否 0%~20%, 80%~100% 处理上下页切换</span></span><br><span class="line">    <span class="keyword">var</span> curIndex = $item.filter(<span class="string">'.current'</span>).index();    <span class="comment">// 当前序号</span></span><br><span class="line">    <span class="keyword">if</span> (px &lt; <span class="number">.2</span>) &#123;</span><br><span class="line">        curIndex = (curIndex + itemCount - <span class="number">1</span>) % itemCount;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (px &gt;= <span class="number">.8</span>) &#123;</span><br><span class="line">        curIndex = (curIndex + <span class="number">1</span>) % itemCount;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 切换当前显示的子元素</span></span><br><span class="line">    $item.removeClass(<span class="string">'current'</span>).eq(curIndex).addClass(<span class="string">'current'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上述代码用原生 JS 写会复杂很多，因为需要离开 jQuery 编写兼容 IE8 的代码，需要对事件绑定、事件对象获取、元素查找、点击坐标、元素坐标等操作做大量兼容处理。做兼容处理的代码甚至会比主要逻辑代码还要多得多。</p><p>有兴趣的同学课余可以尝试一下，使用原生 JS 兼容 IE8 和现代浏览器后，再对比上述代码，就能明白 jQuery 的强大之处了~</p><h3 id="附：可用的跨浏览器兼容的-jQuery-标准化事件属性"><a href="#附：可用的跨浏览器兼容的-jQuery-标准化事件属性" class="headerlink" title="附：可用的跨浏览器兼容的 jQuery 标准化事件属性"></a>附：可用的跨浏览器兼容的 jQuery 标准化事件属性</h3><p>jQuery 按照 W3C 标准规范，将不同浏览器的事件对象处理成了同一格式，免去了日常业务层反复做浏览器兼容的繁琐工作。</p><p>大部分属性只需要参考 W3C 规范即可，各属性具体说明可阅读 jQuery 的 API 文档进行了解：</p><blockquote><p>官方文档：<a href="http://api.jquery.com/category/events/event-object/" target="_blank" rel="noopener">jQuery | Event Object</a></p><p>中文文档：<a href="http://www.jquery123.com/category/events/event-object/" target="_blank" rel="noopener">jQuery | 事件对象</a></p></blockquote><!--## 事件冒泡与事件代理# MVVM## 1. 摆脱 DOM 操作的轮回## 2. 数据驱动的优点（购物车、消息数）## 3. UI 组件化开发## 4. 面向对象（类、实例、方法、字段）# Markdown## 1. Talk is cheap, show me the doc.# Node.js## 1. 从零开始用 JS 写客户端## 2. 站在巨人肩膀上做 GUI 客户端-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;掌握 DOM 的基本概念后，这次我们讲讲浏览器的事件和事件对象。再结合具体业务需求，通过例子展示事件相关的操作方法。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://blog.krimeshu.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://blog.krimeshu.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="初学者" scheme="http://blog.krimeshu.com/tags/%E5%88%9D%E5%AD%A6%E8%80%85/"/>
    
      <category term="事件" scheme="http://blog.krimeshu.com/tags/%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>那些你不知道的 node.js 桌面应用开发框架</title>
    <link href="http://blog.krimeshu.com/2017/06/16/choosing-desktop-gui-framework/"/>
    <id>http://blog.krimeshu.com/2017/06/16/choosing-desktop-gui-framework/</id>
    <published>2017-06-15T16:00:00.000Z</published>
    <updated>2020-08-01T08:52:55.417Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>说到 <code>node.js</code> 的 GUI 开发方案，首先想到的就是 <code>electron</code> 和 <code>nw.js</code>。但除了它们之外，是否存在其它更轻量级的技术方案可供选择呢？</p></blockquote><p><img src="/images/choosing-desktop-gui-framework/node-gui.png" alt="node-gui"></p><a id="more"></a><p>这两天，翻出了几年前在校时用 <code>winform</code> 写的小工具，发现虽然能使用，部分功能却是已经需要改进了。</p><p>工具的源码已经丢失，现在用的电脑里也没有再安装 <code>winform</code> 相关的开发环境。于是决定使用 <code>node.js</code> 重写工具。</p><p>估算一下，重写的核心代码大概也就一、两KB，毕竟只是每次打开后只用几分钟的小工具，用来爬一爬网站内容之类的需求，业务逻辑挺简单的。</p><p>在这个基础上，再加上个方便操作的 GUI 就好了，于是首先想到的方案自然就是 <code>electron</code> 或者 <code>nw.js</code>。</p><p><img src="https://camo.githubusercontent.com/11e7cfd04eceb1ea7464e99edda0e7000487f343/68747470733a2f2f656c656374726f6e2e61746f6d2e696f2f696d616765732f656c656374726f6e2d6c6f676f2e737667" alt="electron"></p><p>但打包了 <code>Chromium</code> 内核和 <code>node.js</code> 环境后，如今的 <code>electron</code> 和 <code>nw.js</code> 动不动就上百MB的大小，用来开发这样的小工具实在是不划算。</p><p>而且在自己另一台破电脑上，<code>electron</code> 启动时间动不动就是十几秒，操作响应也不是很灵敏，达不到小而快的目标效果。</p><p>除了它们之外，是否还有其它的 <code>node.js</code> GUI 开发方案呢？</p><p>于是找了找其它 <code>node.js</code> 的 GUI 框架，大家有兴趣的话可以关注一下：</p><h2 id="positron"><a href="#positron" class="headerlink" title="positron"></a><code>positron</code></h2><p><code>positron</code> 兼容于 <code>electron</code>，只是 Web 内核方面，把 <code>Chromium</code> 换成了 <code>Gecko</code>。</p><p>目前此项目已停止开发。</p><p>项目地址：<a href="https://github.com/mozilla/positron" target="_blank" rel="noopener">https://github.com/mozilla/positron</a></p><h2 id="libui-node"><a href="#libui-node" class="headerlink" title="libui-node"></a><code>libui-node</code></h2><p><img src="https://github.com/parro-it/libui-node/raw/master/docs/media/Window-macOS.png" alt="libui-node"></p><p><code>libui-node</code> 提供了简单便携的基于 C 的 GUI 库，目标是成为相对于 <code>electron</code> 之外跨平台 GUI 开发的轻量级选择。</p><p>跑了一下 DEMO，组件反馈虽然略有迟缓，但可用组件看起来还挺丰富的。</p><p>不过目前整个项目大小有上百MB，暂时似乎没有完善的部署发布方案，希望之后会日渐完善吧。</p><p>项目地址：<a href="https://github.com/parro-it/libui-node" target="_blank" rel="noopener">https://github.com/parro-it/libui-node</a></p><h2 id="react-x11"><a href="#react-x11" class="headerlink" title="react-x11"></a><code>react-x11</code></h2><p><img src="https://cloud.githubusercontent.com/assets/173025/24536323/6af97598-1625-11e7-88d4-74f429b7f470.gif" alt="react-x11"></p><p><code>react-x11</code> 刚刚起步，目前可用组件只有 <code>window</code>，且需要运行在 X Window 环境下（通常是 linux 桌面环境，或者 osx + <code>XQuattz</code>）。</p><p>项目地址：<a href="https://github.com/sidorares/react-x11" target="_blank" rel="noopener">https://github.com/sidorares/react-x11</a></p><h2 id="node-qt"><a href="#node-qt" class="headerlink" title="node-qt"></a><code>node-qt</code></h2><p><img src="https://github.com/arturadib/node-qt/raw/master/examples/helloworld.png" alt="node-qt"></p><p><code>node-qt</code> 以 <code>node.js</code> 附件的形式提供了 Qt 库的原生绑定。</p><p>但在我的 Windows 环境下似乎水土不服，安装失败（貌似是需要 <code>MSVC++</code> 而不是 <code>VS2013</code> 的缘故）。</p><p>项目地址：<a href="https://github.com/yue/node-gui" target="_blank" rel="noopener">https://github.com/yue/node-gui</a></p><h2 id="reactXP"><a href="#reactXP" class="headerlink" title="reactXP"></a><code>reactXP</code></h2><p><code>reactXP</code> 是由微软 skype 团队近期推出的跨平台开发框架（<code>XP</code> = <code>Cross Platform</code>）。支持安卓、iOS、桌面等多平台。</p><p>看起来具体实现基本就是把 <code>react-native</code>、<code>electron</code> 等方案整个打包，再增加了对 Win10 的 UWP 支持，是个大而全而非小而轻的方案？</p><p>项目地址：<a href="https://github.com/Microsoft/reactxp" target="_blank" rel="noopener">https://github.com/Microsoft/reactxp</a></p><hr><p>还有一些不成熟或是有问题的方案，在这就没有列举出来了。</p><p>其他语言方面，尝试了 <code>python</code> 的 <code>Tkinter</code>。发现挺方便的，安装完 <code>Python</code> 就能使用，但能实现的效果似乎很有限；<code>PyQt</code> 更强大、美观，但需要花时间去学习 QT，没法现在就立刻动手做。</p><p>而且两者都不如类 Web 的 GUI 方案来的灵活便捷（<code>React</code> 也算此类）。</p><p>这么说来，近几年桌面开发似乎越来越不温不火，大家的关注中心似乎都转移到了移动端上。</p><p>而移动端的话，原生开发方面，从传统原生开发方式与 <code>react-native</code> 的出现、苹果推出 <code>Swift</code>，到最近谷歌钦定 <code>Kotlin</code> 作为安卓开发的一级语言；Web 前端开发方面，<code>node.js</code> 带来的 <code>grunt</code>、<code>gulp</code>、<code>webpack</code> 工作流，以及各种优秀 MVVM 框架竞相出现，新技术不断出现，让前端开发成为了众所周知最爱造轮子的一拨人。</p><p>移动端涌现的各种新工具、框架、语言，对行业入门者来说有一定学习成本，但也确实带来了种种便利。它们一般都解决了各种以往开发方式中的痛点</p><p>对于日渐变化的移动端开发需求，确实提高了生产效率，改善开发体验。但新出现的方案毕竟需要在实践中逐步完善，所以它们每天都在不断迭代更新，甚至又出现更新的其它方案。</p><p>或许可以这么说，我们现在正经历着桌面端开发向移动端转移中心的过渡期。桌面端 GUI 开发的需求存在感日渐稀薄，现有传统开发方案已能应对日常需求，所以虽然也有一些技术痛点，却并没有更新开发方式的必要。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这次的小工具的开发，最后采用的形式是编写好关键的 JS 脚本，加入 <code>Greasemonkey</code> 后直接在浏览器内执行，抓取需要的内容。</p><p>除此之外，做成 <code>Chrome</code> 插件，或者直接写成命令行工具，也是可选的轻量级方案。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;说到 &lt;code&gt;node.js&lt;/code&gt; 的 GUI 开发方案，首先想到的就是 &lt;code&gt;electron&lt;/code&gt; 和 &lt;code&gt;nw.js&lt;/code&gt;。但除了它们之外，是否存在其它更轻量级的技术方案可供选择呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/images/choosing-desktop-gui-framework/node-gui.png&quot; alt=&quot;node-gui&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="node.js" scheme="http://blog.krimeshu.com/categories/node-js/"/>
    
    
      <category term="node.js" scheme="http://blog.krimeshu.com/tags/node-js/"/>
    
      <category term="桌面应用" scheme="http://blog.krimeshu.com/tags/%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/"/>
    
      <category term="感想" scheme="http://blog.krimeshu.com/tags/%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>由重构进阶前端开发入门 (一) DOM 操作</title>
    <link href="http://blog.krimeshu.com/2017/05/04/basic-knowledge-points-for-beginner/"/>
    <id>http://blog.krimeshu.com/2017/05/04/basic-knowledge-points-for-beginner/</id>
    <published>2017-05-03T16:00:00.000Z</published>
    <updated>2020-08-01T08:52:55.417Z</updated>
    
    <content type="html"><![CDATA[<p>虽然前端的技术每年都在不断更新，但新人们都还是从基础的 HTML、CSS 样式开始学 Web 前端开发的。</p><p>这样切图、使用 HTML + CSS 编写网页的工作过程，我们一般称之为<code>网页重构</code>，关于<code>网页重构</code>和<code>前端开发</code>是否应该分离也一直存在争议。</p><p>但就日常工作的情况来看，二者还是很难彻底分开的，前端开发写脚本时必定需要网页重构的基础（比如动画控制、3D变换等），网页重构时也需要提前考虑前端脚本可控制标签的埋点，尽量避免后期再对页面结构和样式调整改动。</p><p>总体来说，前端开发是一个主要的发展方向，近几年来也是大趋势。</p><p>那么，新同学们掌握网页重构后，又该开始哪些知识的学习？以便向前端开发进阶，拓展自己的技能树、全面发展呢？</p><p>个人认为主要需要学习的都是各类 JS 知识点。这里对相关知识点稍作整理归类，可能分几篇文章各自小结一下，希望能抛砖引玉，对新人们的学习有所帮助。</p><a id="more"></a><h1 id="DOM-操作"><a href="#DOM-操作" class="headerlink" title="DOM 操作"></a>DOM 操作</h1><h2 id="1-什么是-DOM"><a href="#1-什么是-DOM" class="headerlink" title="1. 什么是 DOM"></a>1. 什么是 DOM</h2><p>做前端开发，每天都在和 DOM 打着交道，那么 DOM 到底是什么呢？</p><p>有人可能会说它们就是页面里的 HTML 标签，但这么描述其实不够确切，W3C 对其的标准定义是：</p><blockquote><p>“W3C 文档对象模型 （DOM） 是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。”</p></blockquote><p>具体点说，其实是浏览器拿到 Web 文档后，对 HTML 标签进行分析，处理成了对应的可操作对象，这类对象被称为<code>文档对象模型(Document Object Model, DOM)</code>。</p><p>而除了页面里的标签外，我们也可以自己手动创建 DOM 的，所以 DOM 的来源不只是页面里的 HTML 标签。</p><p>获得 DOM 对象之后，我们还可以对它们做一系列操作，以满足日常各种页面开发需求。</p><h2 id="2-常用-API"><a href="#2-常用-API" class="headerlink" title="2. 常用 API"></a>2. 常用 API</h2><h3 id="2-1-修改内容"><a href="#2-1-修改内容" class="headerlink" title="2.1 修改内容"></a>2.1 修改内容</h3><p>来看看最常见，也是最基本的需求之一，修改页面内某个位置的文本，想必大家都做过这样的操作。</p><p>比如在页面某处显示当前的时间：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    当前时间是：<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"txt_currTime"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>首先需要获取页面元素对应的 DOM 来进行操作，大家一般常用 <code>getElementById</code>。其它方式需要自己注意浏览器兼容性问题，以及区分单个 DOM 和 DOM 数组返回值的情况。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 定时修改时间文本</span></span></span><br><span class="line"><span class="javascript">    setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> currTime = <span class="built_in">document</span>.getElementById(<span class="string">'txt_currTime'</span>);</span></span><br><span class="line"><span class="javascript">        currTime.textContent = <span class="keyword">new</span> <span class="built_in">Date</span>();</span></span><br><span class="line"><span class="undefined">    &#125;, 1000);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>根据 <code>id</code> 找到占位的 <code>span</code> 标签对应 DOM 后，修改 DOM 的 <code>textContent</code> 属性，浏览器自动反馈到页面更新，就完成了修改页面内容的常见操作。</p><p>这里只做简要介绍，涉及到 <code>textContent</code> 的兼容性问题，以及与 <code>innerText</code>、<code>innerHTML</code> 的区别问题，想要深入学习的可以参考：<a href="http://www.cnblogs.com/fsjohnhuang/p/4319635.html" target="_blank" rel="noopener">《JS魔法堂：被玩坏的innerHTML、innerText、textContent和value属性》</a>。</p><h3 id="2-2-修改样式"><a href="#2-2-修改样式" class="headerlink" title="2.2 修改样式"></a>2.2 修改样式</h3><p>最常见的需求之二，修改页面某处元素的显示效果。</p><p>直接修改样式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.title</span> &#123;</span></span><br><span class="line"><span class="undefined">        color: red;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"title"</span> <span class="attr">id</span>=<span class="string">"txt_mainTitle"</span>&gt;</span></span><br><span class="line">    标题文本</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 修改标题字体样式</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">'txt_mainTitle'</span>).style.fontWeight = <span class="string">'bold'</span>;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过切换 <code>class</code> 修改显示效果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.title</span> &#123;</span></span><br><span class="line"><span class="undefined">        color: red;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.title</span><span class="selector-class">.current</span> &#123;</span></span><br><span class="line"><span class="undefined">        font-weight: bold;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"title"</span> <span class="attr">id</span>=<span class="string">"txt_mainTitle"</span>&gt;</span></span><br><span class="line">    标题文本</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 修改标题样式 class</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">'txt_mainTitle'</span>).classList.add(<span class="string">'current'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// document.getElementById('txt_mainTitle').className += (' current');</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-3-动态创建元素"><a href="#2-3-动态创建元素" class="headerlink" title="2.3 动态创建元素"></a>2.3 动态创建元素</h3><p>最常见需求之三，根据获得的数据，动态创建页面元素。</p><p>最基本的方法就是修改 <code>innerHTML</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"lst_msgList"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">renderMsgList</span>(<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> list = <span class="built_in">document</span>.getElementById(<span class="string">'lst_msgList'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> buffer = <span class="string">''</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = data.length; i &lt; l; i++) &#123;</span></span><br><span class="line"><span class="javascript">            buffer += <span class="string">'&lt;li&gt;'</span> + data[i] + <span class="string">'&lt;/li&gt;'</span>;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">        list.innerHTML = buffer;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>更标准的方法则是通过 <code>document.createElement</code> 创建 DOM 后，加入到指定位置：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"lst_msgList"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">renderMsgList</span>(<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> list = <span class="built_in">document</span>.getElementById(<span class="string">'lst_msgList'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = data.length; i &lt; l; i++) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> item = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span></span><br><span class="line"><span class="undefined">            item.textContent = data[i];</span></span><br><span class="line"><span class="undefined">            list.appendChild(item);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>过去，使用 <code>innerHTML</code> 的性能高于 <code>createElement</code> 创建元素。但经过浏览器迭代优化后，两者性能已经相差无几了。</p><p>而且，在父元素内已有大量子元素时，需要在子元素内删除成员或插入新成员时，直接修改父元素的 <code>innerHTML</code> 会导致所有子元素重新渲染，性能开销大。</p><blockquote><p><code>list.innerHTML += newElements;</code> 本质上其实是 <code>var newHTML = list.innerHTML + newElements; list.innerHTML = newHTML;</code> 依然渲染了整个列表，而非追加元素。</p></blockquote><p>而且重新渲染创建的子元素与之前的子元素并非同一实例，会丢失之前对子元素绑定的事件监听器，导致各种意外情况，需要注意。</p><h2 id="3-属性-Property-与特性-Attribute"><a href="#3-属性-Property-与特性-Attribute" class="headerlink" title="3. 属性 (Property) 与特性 (Attribute)"></a>3. 属性 (Property) 与特性 (Attribute)</h2><p>两者有时候都被称为“属性”，容易混淆，简单区分的话，可以这么理解：</p><p><code>Attribute</code> 是 <code>HTML</code> 形式表示时的页面元素内原有的属性（特性），比如 <code>id</code>、<code>name</code>、<code>value</code>、<code>title</code> 以及各种自定义的 <code>data-xxxx</code>。</p><p><code>Property</code> 则是脚本内获取到的 DOM 对象附带的字段属性，如 <code>id</code>、<code>innerHTML</code> 等。</p><table><thead><tr><th style="text-align:left">字段</th><th style="text-align:left">是否属性</th><th style="text-align:left">是否特性</th></tr></thead><tbody><tr><td style="text-align:left">id</td><td style="text-align:left">√</td><td style="text-align:left">√</td></tr><tr><td style="text-align:left">innerHTML</td><td style="text-align:left">√</td><td style="text-align:left">×</td></tr><tr><td style="text-align:left">data-xxxx</td><td style="text-align:left">×</td><td style="text-align:left">√</td></tr></tbody></table><p>操作 <code>Attribute</code> 的标准方法是调用 DOM 的 <code>getAttribute(key)</code> 和 <code>setAttribute(key, value)</code>，其中 <code>getAttribute</code> 的返回值和 <code>setAttribute</code> 第二个参数 <code>value</code> 都必需是字符串类型。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"title"</span> <span class="attr">id</span>=<span class="string">"txt_mainTitle"</span> <span class="attr">data-index</span>=<span class="string">"1"</span> <span class="attr">style</span>=<span class="string">"color: red;"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> mainTitle = <span class="built_in">document</span>.getElementById(<span class="string">'txt_mainTitle'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    mainTitle.getAttribute(<span class="string">'id'</span>);           <span class="comment">// 'txt_mainTitle'</span></span></span><br><span class="line"><span class="javascript">    mainTitle.setAttribute(<span class="string">'title'</span>, <span class="string">'This is a title.'</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>Property</code> 则是直接使用 JS 对象的字段读写操作就行了，<code>title.id</code> 或 <code>title[&#39;id&#39;]</code> 皆可。</p><p>常用的 <code>Attribute</code>，例如 <code>id</code>、<code>title</code> 等，会被浏览器自动转为 <code>Property</code> 附加到 DOM 对象上，方便日常操作。</p><p>不过有些需要注意的情况：</p><ol><li><p>因为 <code>class</code> 是 <code>ECMA</code> 的关键字，作为 <code>Property</code> 使用时字段名叫做 <code>className</code>；</p></li><li><p>为了便于操作，<code>style</code> 会被转化成对象形式（键值对），而非其它特性的字符串值。</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mainTitle.id === mainTitle.getAttribute(<span class="string">'id'</span>);              <span class="comment">// true</span></span><br><span class="line">mainTitle.className === mainTitle.getAttribute(<span class="string">'class'</span>);    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">mainTitle.style;                                            <span class="comment">// &#123; color: 'red', ... &#125;</span></span><br></pre></td></tr></table></figure><p>除了 HTML 标准内的 <code>Attribute</code> 之外，我们可以添加各种自定义 <code>Attribute</code> 一般会用于在创建或渲染元素时，附加特定的文本信息。</p><p>这些信息对用户不可见，但在页面源代码和浏览器调试工具的 DOM 树内能清晰看到，方便开发者进行元素选取和页面调试等操作。</p><p>但这些自定义 <code>Attribute</code> 不会自动转为 <code>Property</code> 处理，需要通过 <code>getAttribute</code>/<code>setAttribute</code> 进行操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mainTitle.getAttribute(<span class="string">'data-index'</span>);   <span class="comment">// '1'</span></span><br></pre></td></tr></table></figure><p><code>Property</code> 操作更加自由，但一般还是不推荐给 DOM 增加自定义 <code>Property</code>，因为操作不当时会影响部分浏览器的垃圾回收检测，容易导致内存泄漏。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文是入门内容，只讲述了最常见的几种情况，更多 DOM 操作可以自行根据需求，在 <code>W3School</code> 等网站查找更多 API 结合实例进行练习。</p><p>由于历史原因，很多 API 涉及到浏览器兼容性问题，建议新手在练习中进行了解，便于日后碰到问题时知道如何应对。</p><p>但日常生产环境内，推荐优先使用 jQuery 等框架来处理，而非自己处理兼容性问题。</p><p>因为很多兼容性问题需要结合实际情况进行针对处理，产生的代码不方便他人阅读，不利于协同开发。</p><p>而且要处理得较为完善，需要对现有 API 进行大量封装，这些工作现有框架已经完成得很出色了，没必要特意重新造轮子。</p><p>因此，后续文章将以 jQuery 为例，在介绍原生 DOM 操作 API 之后，给出 jQuery 的处理方案进行对比。希望初学者了解其中原由，不要混淆两者的操作（见过很多新手混淆原生与 jQuery API，有些无奈……）。</p><!--# 事件与事件对象## 1. 什么是事件## 2. 处理事件### 事件属性### 事件监听器## 3. 事件冒泡与捕获## 4. 事件对象## 5. 事件代理# MVVM## 1. 摆脱 DOM 操作的轮回## 2. 数据驱动的优点（购物车、消息数）## 3. UI 组件化开发## 4. 面向对象（类、实例、方法、字段）# Markdown## 1. Talk is cheap, show me the doc.# Node.js## 1. 从零开始用 JS 写客户端## 2. 站在巨人肩膀上做 GUI 客户端-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然前端的技术每年都在不断更新，但新人们都还是从基础的 HTML、CSS 样式开始学 Web 前端开发的。&lt;/p&gt;
&lt;p&gt;这样切图、使用 HTML + CSS 编写网页的工作过程，我们一般称之为&lt;code&gt;网页重构&lt;/code&gt;，关于&lt;code&gt;网页重构&lt;/code&gt;和&lt;code&gt;前端开发&lt;/code&gt;是否应该分离也一直存在争议。&lt;/p&gt;
&lt;p&gt;但就日常工作的情况来看，二者还是很难彻底分开的，前端开发写脚本时必定需要网页重构的基础（比如动画控制、3D变换等），网页重构时也需要提前考虑前端脚本可控制标签的埋点，尽量避免后期再对页面结构和样式调整改动。&lt;/p&gt;
&lt;p&gt;总体来说，前端开发是一个主要的发展方向，近几年来也是大趋势。&lt;/p&gt;
&lt;p&gt;那么，新同学们掌握网页重构后，又该开始哪些知识的学习？以便向前端开发进阶，拓展自己的技能树、全面发展呢？&lt;/p&gt;
&lt;p&gt;个人认为主要需要学习的都是各类 JS 知识点。这里对相关知识点稍作整理归类，可能分几篇文章各自小结一下，希望能抛砖引玉，对新人们的学习有所帮助。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://blog.krimeshu.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://blog.krimeshu.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="初学者" scheme="http://blog.krimeshu.com/tags/%E5%88%9D%E5%AD%A6%E8%80%85/"/>
    
      <category term="DOM" scheme="http://blog.krimeshu.com/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>在你开发微信小程序时能用上的那些ES6特性</title>
    <link href="http://blog.krimeshu.com/2017/02/27/tricks-from-es6-for-mina/"/>
    <id>http://blog.krimeshu.com/2017/02/27/tricks-from-es6-for-mina/</id>
    <published>2017-02-26T16:00:00.000Z</published>
    <updated>2020-08-01T08:52:55.422Z</updated>
    
    <content type="html"><![CDATA[<p>微信小程序的官方开发工具中，已经集成了 <code>babel</code> 插件对 <code>ES6</code> 语法进行转换，各种第三方工具自然更少不了了。</p><p>所以可以放心的尝试使用 <code>ES6</code>，体验新标准带来的各种便利之处，省下时间后学习充电，或者早点下班、锻炼身体、下厨做个菜，调节生活又放松身心，岂不美哉？</p><p>那么，在小程序开发的过程中，有哪些 <code>ES6</code> 特性是可以给我们带来便利，提高开发效率的呢？这边就结合实例，一一来说一说吧。</p><a id="more"></a><h2 id="1-箭头表达式"><a href="#1-箭头表达式" class="headerlink" title="1. 箭头表达式"></a>1. 箭头表达式</h2><p>做前端开发的，开始阶段基本会遇到 <code>this</code> 与 <em>闭包</em> 带来的坑————一些异步操作中，回调函数中丢失了当前函数的上下文对象，导致异步操作完成后，更新原有上下文失败。</p><p>为了避免这个问题，以前大家都是自己用变量保存一个闭包外部上下文的引用，取的名字可能千奇百怪：<br><code>that</code>/<code>_this</code>/<code>$this</code>/<code>self</code>…在异步操作完成后的回调中，通过调取这个闭包外层的变量，达到更新回调前函数上下文对象的目的。</p><p><code>ES6</code> 中增加了 <em>箭头表达式</em>，效果和匿名函数相似，但箭头表达式更为简练，且内部执行时的 <code>this</code> 与外侧一致，不再需要每次都额外增加变量引用了。</p><p>微信小程序里，对每个页面编写的代码逻辑，都作为生命周期钩子函数（如：onLoad, onShow, onUnload）和自定义函数（如：各类组件回调函数）写在 <code>AppService</code> 内。</p><p>这两种函数内，<code>this</code> 都指向当前 <code>Page</code> 对象，在这些函数里做的各种异步操作，回调内的 <code>this</code> 基本都应该仍然保持为当前 <code>Page</code> 对象。在这个情况下，使用箭头表达式可以减少重复的工作、也减少遗漏 <code>this</code> 时出错的几率。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'../public/net'</span>);</span><br><span class="line">Page(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        list: []</span><br><span class="line">    &#125;,</span><br><span class="line">    onShow: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">        net.get(<span class="string">'/Index/getList'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">            res = res || &#123;&#125;;</span><br><span class="line">            <span class="keyword">var</span> status = res.status,</span><br><span class="line">                data = res.data,</span><br><span class="line">                list = data.list;</span><br><span class="line">            <span class="keyword">if</span>(status == <span class="number">2</span>) &#123;</span><br><span class="line">                self.setData(&#123;<span class="attr">list</span>: list&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> net <span class="keyword">from</span> <span class="string">'../public/net'</span>;</span><br><span class="line">Page(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        list: []</span><br><span class="line">    &#125;,</span><br><span class="line">    onShow: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        net.get(<span class="string">'/Index/getList'</span>, (res = &#123;&#125;) =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> &#123;status, <span class="attr">data</span>: &#123;list&#125;&#125; = res;</span><br><span class="line">            <span class="keyword">if</span> (status == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// 此处 this 的指向与 onShow 内一致，无需增加 self 变量</span></span><br><span class="line">                <span class="keyword">this</span>.setData(&#123;list&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="2-数组方法"><a href="#2-数组方法" class="headerlink" title="2. 数组方法"></a>2. 数组方法</h2><p>虽然都说微信小程序 <code>wxml</code> 的 <code>Mustache</code> 语法与 <code>Vue.js</code> 很相似。但据说是为了分离 <code>UI</code> 线程和 <code>AppService</code> 线程，微信小程序暂时并不支持 <code>&amp;#123;&amp;#123;value | filter}}</code> 的写法。</p><p>这时候可以借助于 <code>ES5</code> 中为数组对象增加的方法，之前因为浏览器兼容性问题，不一定全部能用。如今在移动端了，就尽情用起来吧：</p><p>输出数据前，对后台传来的列表数据做一些预处理后再显示时，通常使用 <code>Array.prototype.forEach</code> 和 <code>Array.prototype.map</code> 进行相应处理；<br>筛选掉无效数据，可以使用 <code>Array.prototype.filter</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// js</span></span><br><span class="line"><span class="keyword">var</span> helpers = &#123;</span><br><span class="line">    <span class="comment">// 判断是否有时间参数</span></span><br><span class="line">    hasTime: <span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="built_in">isNaN</span>(<span class="built_in">parseInt</span>(i.stamp));</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 时间转换处理</span></span><br><span class="line">    parseTime: <span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">        i.time = <span class="keyword">new</span> <span class="built_in">Date</span>(i.stamp + <span class="string">'000'</span>);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">net.get(<span class="string">'/Index/getList'</span>, (res = &#123;&#125;) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;status, <span class="attr">data</span>: &#123;list&#125;&#125; = res;</span><br><span class="line">    <span class="keyword">this</span>.set(&#123;</span><br><span class="line">        list: list.filter(helpers.hasTime)  <span class="comment">// 筛选掉没有时间戳字段的数据</span></span><br><span class="line">                  .map(helpers.parseTime)   <span class="comment">// 将时间戳字段转化为 JS 的 Date 对象</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="3-Rest-解构赋值"><a href="#3-Rest-解构赋值" class="headerlink" title="3. Rest 解构赋值"></a>3. Rest 解构赋值</h2><p>直到写这篇文章的时候，小程序官方的组件标准也仍然没有出来。</p><p>目前的通常处理方案，一般是通过 <code>template</code> 配合解构赋值不同对象的数据，实现组件各自状态、事件处理函数互相独立的效果。</p><p>如，有两个 <code>template</code> 都从 <code>data</code> 中绑定数据。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">name</span>=<span class="string">"banner"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"banner-wrap"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">"&#123;&#123;data&#125;&#125;"</span> <span class="attr">class</span>=<span class="string">"banner-item"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--...--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">name</span>=<span class="string">"comic-list"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"comic-list"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">"&#123;&#123;data&#125;&#125;"</span> <span class="attr">class</span>=<span class="string">"comic-item"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--...--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>AppService</code> 中对于这两个模板创建两个不同对象，即可管理自身状态，不用担心字段名重复的问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">    onLoad: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 加载 Banner 数据并显示</span></span><br><span class="line">        <span class="keyword">this</span>.loadData(<span class="string">'/bannerState/get'</span>, (data) =&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">                bannerState: data</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 加载 ComicList 数据并显示</span></span><br><span class="line">        <span class="keyword">this</span>.loadData(<span class="string">'/comicListState/get'</span>, (data) =&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">                comicListState: data</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    loadData: <span class="function"><span class="keyword">function</span> (<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> data = [];</span><br><span class="line">        <span class="comment">/* 从 url 加载数据的逻辑 */</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            callback(&#123;</span><br><span class="line">                data: data</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>页面内渲染模板时，对 <code>bannerState</code> 和 <code>comicListState</code> 字段进行解构即可。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">is</span>=<span class="string">"banner"</span> <span class="attr">data</span>=<span class="string">"&#123;&#123;...bannerState&#125;&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">is</span>=<span class="string">"comicList"</span> <span class="attr">data</span>=<span class="string">"&#123;&#123;...comicListState&#125;&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这是个非常重要且实用的特性，基于这个基础可以封装出有具有通用逻辑的基类，实现模块内部的逻辑闭环，达到组件化开发的效果。</p><h2 id="4-增强的对象字面量"><a href="#4-增强的对象字面量" class="headerlink" title="4. 增强的对象字面量"></a>4. 增强的对象字面量</h2><h3 id="setData"><a href="#setData" class="headerlink" title="setData()"></a><code>setData()</code></h3><p><code>setData()</code> 中的数据字段名与变量名一致时，不需要重复写两遍，上面加载数据的代码就可以这样简写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.loadData(<span class="string">'/bannerState/get'</span>, (bannerState) =&gt; &#123;</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">        bannerState</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>数据字段较多时，效率会快很多。减少了整理和重构代码需要调整的地方，降低维护成本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统对象字面量</span></span><br><span class="line"><span class="keyword">this</span>.setData(&#123;</span><br><span class="line">    data1: data1,</span><br><span class="line">    data2: data2,</span><br><span class="line">    data3: data3,</span><br><span class="line">    data4: data4,</span><br><span class="line">    data5: data5</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增强的对象字面量</span></span><br><span class="line"><span class="keyword">this</span>.setData(&#123;data1, data2, data3, data4, data5&#125;);</span><br></pre></td></tr></table></figure><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>增强的对象字面量写法，还包括函数的简写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统的对象字面量</span></span><br><span class="line"><span class="keyword">var</span> comicState = &#123;</span><br><span class="line">    onTap: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    onScroll: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增强的对象字面量</span></span><br><span class="line"><span class="keyword">var</span> comicState = &#123;</span><br><span class="line">    onTap(e) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    onScroll(e) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种简洁的成员函数写法，是不是很像 <code>class</code> 中的函数声明？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComicState</span> </span>&#123;</span><br><span class="line">    onTap (e) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    onScroll (e) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-Class-与继承"><a href="#5-Class-与继承" class="headerlink" title="5. Class 与继承"></a>5. Class 与继承</h2><p>使用 <code>ES5</code> 的 <code>prototype</code> 写法，实现简单的类继承也没太大问题，但涉及到父类函数调用等情况，代码耦合度会变得更高，需要一定经验才能写出方便维护的代码。</p><p>通过 <code>ES6</code> 语法来实现类继承的话，有了统一的标准，写出的类继承更加直观，更方便调整。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> (options, otherArg) &#123;</span><br><span class="line">        <span class="comment">// Do something.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildType</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> (options) &#123;</span><br><span class="line">        <span class="keyword">super</span>(options, ChildType);</span><br><span class="line">        <span class="comment">// Do something.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-块作用域变量"><a href="#6-块作用域变量" class="headerlink" title="6. 块作用域变量"></a>6. 块作用域变量</h2><p>使用 <code>for</code> 对数据做迭代遍历时，语句中声明的 <code>var</code> 型变量名作用域其实提升到了函数顶部，不同迭代间忘记处理的话，可能会导致数据污染。</p><p>改为使用 <code>ES6</code> 的 <code>let</code>/<code>const</code> 可避免这一情况，放心使用块级作用域。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> data1) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">let</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> data2) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><p>微信小程序使用的 <code>babel</code> 启用的转码规则可能不是最新的，截止目前版本，测试使用以下 <code>ES6</code> 会有问题，需要注意。</p><ul><li><code>class</code> 内部声明的静态字段；</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下代码在 babel 的 repl 中能正常处理，在小程序开发工具内会报错</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> MODE = &#123;</span><br><span class="line">        NORMAL: <span class="number">1</span>,</span><br><span class="line">        DISABLED: <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：1</span></span><br><span class="line"><span class="built_in">console</span>.log(TestClass.MODE.NORMAL);</span><br></pre></td></tr></table></figure><ul><li><del><code>for...of</code> 语法遍历对象（直接使用了 <code>Symbol.iterator</code>，移动端可能尚未实现）；</del> </li></ul><blockquote><p>20170329 更新：新版本开发工具似乎已经完善了这个问题，可以使用下面的 <code>ES6</code> 写法了：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">Test.prototype = &#123;</span><br><span class="line">    c: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> o) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k.hasOwnProperty(k)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(o[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   <span class="comment">// 输出：1 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">of</span> <span class="built_in">Object</span>.keys(o)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(o[k]);</span><br><span class="line">&#125;   <span class="comment">// 输出：1 2</span></span><br></pre></td></tr></table></figure><p><code>for...of</code> 用于数组遍历时，效果与 <code>Array.prototype.forEach</code> 类似，区别是可以在途中 <code>break</code> 中断循环，无需每次遍历整个数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array.prototype.forEach</span></span><br><span class="line">comicList.forEach(<span class="function">(<span class="params">c</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// for...of</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> c <span class="keyword">of</span> comicList) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微信小程序的官方开发工具中，已经集成了 &lt;code&gt;babel&lt;/code&gt; 插件对 &lt;code&gt;ES6&lt;/code&gt; 语法进行转换，各种第三方工具自然更少不了了。&lt;/p&gt;
&lt;p&gt;所以可以放心的尝试使用 &lt;code&gt;ES6&lt;/code&gt;，体验新标准带来的各种便利之处，省下时间后学习充电，或者早点下班、锻炼身体、下厨做个菜，调节生活又放松身心，岂不美哉？&lt;/p&gt;
&lt;p&gt;那么，在小程序开发的过程中，有哪些 &lt;code&gt;ES6&lt;/code&gt; 特性是可以给我们带来便利，提高开发效率的呢？这边就结合实例，一一来说一说吧。&lt;/p&gt;
    
    </summary>
    
      <category term="小程序" scheme="http://blog.krimeshu.com/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="微信小程序" scheme="http://blog.krimeshu.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="ES6" scheme="http://blog.krimeshu.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>探索PHP与Vue通用直出模板方案</title>
    <link href="http://blog.krimeshu.com/2017/02/13/vue-php-template-convertor/"/>
    <id>http://blog.krimeshu.com/2017/02/13/vue-php-template-convertor/</id>
    <published>2017-02-12T16:00:00.000Z</published>
    <updated>2020-08-01T08:52:55.422Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>测试方案，欢迎提出新的思路，共同探讨！</p></blockquote><img src="/images/vue-php-template-convertor/cover-1.png" title="cover"><a id="more"></a><h2 id="什么是“页面直出”"><a href="#什么是“页面直出”" class="headerlink" title="什么是“页面直出”"></a>什么是“页面直出”</h2><p>我们通常说的“页面直出”，其实就是服务端渲染（SSR, Server-Side Render）。</p><p>最初的 JS SPA 方案有个常见的问题，就是脚本没有加载执行完时，页面中没有内容。不仅影响访问体验，还不利于 SEO。</p><p>于是大家要么使用传统的 JSP、PHP、ASP.NET 服务端页面模板，要么采用最新的 React/Vue 服务端渲染方案。</p><h2 id="PHP-与-React-Vue-SSR"><a href="#PHP-与-React-Vue-SSR" class="headerlink" title="PHP 与 React/Vue SSR"></a>PHP 与 React/Vue SSR</h2><p>目前动漫 H5 主站的前端架构没有使用 MVVM，存在大量累赘的 DOM 操作代码。</p><p>于是考虑切换到 React/Vue 方案，通过双向绑定和组件开发，简化累赘代码，提高可维护性和测试可能性。</p><p>但是为了优化 SEO 效果，H5主站需要做页面直出，而常用的 React/Vue 直出都是基于 node.js 服务端的，我们现有的服务端环境是 PHP，并不能直接使用。</p><h3 id="方案1：php-v8js"><a href="#方案1：php-v8js" class="headerlink" title="方案1：php-v8js"></a>方案1：php-v8js</h3><p>首先找到的是 php-v8j，也就是实现一个 PHP 服务端的 JS V8 运行环境。</p><p>但根据 Vue 作者的回复，Vue 依赖于一些第三方模块，以及使用了 node.js 的 stream 等功能，php-v8js 提供的环境并不能实现 Vue 的服务端直出。</p><blockquote><p>参考地址，Vue作者对于 php 环境下 SSR 的回复：<a href="https://github.com/vuejs/vue/issues/4101" target="_blank" rel="noopener">https://github.com/vuejs/vue/issues/4101</a></p></blockquote><p>React 的话，有一篇文章，描述了通过 php-v8js 实现的 React SSR (Server-Side Render)。</p><blockquote><p>参考地址，使用 react-php-v8js 实现 SSR：<a href="http://www.phpied.com/server-side-react-with-php/" target="_blank" rel="noopener">http://www.phpied.com/server-side-react-with-php/</a></p></blockquote><p>目前看来，至少使用 React 的方案是可行的。</p><p>可是即便如此，Github 的 react-php-v8js 仍然是“实验性”的项目，php-v8js 的人气也不是很高，issue 中看来可能也会潜在不少问题。两者一起使用，风险较大。</p><p>并且 php-v8js 是在 PHP 内运行了个 v8 的沙盒运行环境，执行效率有待商榷。而 React/Vue 使用的虚拟 DOM 虽然在 v8 引擎内渲染速度不错，但相比传统字符串拼接的模板引擎仍然多了不少性能开销，React 很早实现了服务端渲染却没有铺开，便是出于对 node.js 服务端普及率和渲染性能的考虑。</p><h3 id="方案2：mustache-php"><a href="#方案2：mustache-php" class="headerlink" title="方案2：mustache.php"></a>方案2：mustache.php</h3><p>通过搜索 php js template，发现 Mustache 其实已经实现了 <a href="https://github.com/mustache/mustache" target="_blank" rel="noopener">Ruby</a>, <a href="https://github.com/janl/mustache.js" target="_blank" rel="noopener">JavaScript</a>, <a href="https://github.com/defunkt/pystache" target="_blank" rel="noopener">Python</a>,<a href="https://github.com/mojombo/mustache.erl" target="_blank" rel="noopener">Erlang</a>, <a href="https://github.com/raycmorgan/Mu" target="_blank" rel="noopener">node.js</a>, <a href="https://github.com/bobthecow/mustache.php" target="_blank" rel="noopener">PHP</a>, <a href="https://github.com/pvande/Template-Mustache" target="_blank" rel="noopener">Perl</a>, <a href="https://github.com/groue/GRMustache" target="_blank" rel="noopener">Objective-C</a>, <a href="https://github.com/spullara/mustache.java" target="_blank" rel="noopener">Java</a>, <a href="https://github.com/jdiamond/Nustache" target="_blank" rel="noopener">C#/.NET</a>, <a href="https://github.com/samskivert/jmustache" target="_blank" rel="noopener">Android</a>, C++,<a href="https://github.com/cbroglie/mustache" target="_blank" rel="noopener">Go</a>, <a href="https://github.com/Olivine-Labs/lustache" target="_blank" rel="noopener">Lua</a>, <a href="https://github.com/nagaozen/asp-xtreme-evolution/blob/master/lib/axe/classes/Parsers/mustache.asp" target="_blank" rel="noopener">ASP</a>, <a href="https://github.com/mil/mustache.io" target="_blank" rel="noopener">Io</a>, <a href="https://github.com/valotas/mustache4dart" target="_blank" rel="noopener">Dart</a>, <a href="https://github.com/nadako/hxmustache" target="_blank" rel="noopener">Haxe</a>,<a href="https://github.com/synopse/dmustache" target="_blank" rel="noopener">Delphi</a>, <a href="https://github.com/groue/GRMustache.swift" target="_blank" rel="noopener">Swift</a>, <a href="https://github.com/tests-always-included/mo" target="_blank" rel="noopener">Bash</a> 等各种平台和语言的支持。</p><blockquote><p>Mustache 主页: <a href="http://mustache.github.io/" target="_blank" rel="noopener">http://mustache.github.io/</a></p></blockquote><p>其中 PHP 平台可以使用 mustache.php 作为模板引擎，进行服务端页面渲染。</p><blockquote><p>mustache.php: <a href="https://github.com/bobthecow/mustache.php" target="_blank" rel="noopener">https://github.com/bobthecow/mustache.php</a></p></blockquote><p>通过在服务器环境下加入 mustache.php，既可实现前端后台使用统一的 Mustach 语法模板渲染效果。</p><p>但是 Mustache 语法与 Vue.js 并不完全兼容（如循环、if 等写法），而 Mustache 本身只是单纯无逻辑的渲染模板，并不能满足我们 MVVM 改造的需求，所以是否使用 mustache.php 仍然有待考虑。</p><h2 id="为什么需要直出？"><a href="#为什么需要直出？" class="headerlink" title="为什么需要直出？"></a>为什么需要直出？</h2><p>回到开始的问题，为什么需要做页面直出呢？SEO 吗？</p><p>而为了 SEO 而需要直出的页面有哪些？</p><p>这些页面是否都是与用户个人状态无关，可以直接缓存的？</p><p>那这些页面使用 PHP 运行 php-v8js 跑出一遍结果后，进行页面缓存，其它页面直接使用前端 React + ajax 渲染数据。是否可行？</p><p>php-v8js 出现页面渲染意外的可能性多大？</p><p>提供异常时切换到普通方案是否可行？</p><h2 id="思考解决方案"><a href="#思考解决方案" class="headerlink" title="思考解决方案"></a>思考解决方案</h2><p>需要直出的页面一般与用户个人状态无关，可以在服务器端进行页面内容缓存，提高访问效率，利于 SEO。</p><p>为了服务端稳定，建议不建议使用重量级的服务端渲染库，尽可能减少现有系统的变动，避免运行中的系统出现异常。而出现异常时切换到普通方案的紧急方案也需要精力去实现和维护，成本略高。</p><h2 id="换个思路，简化问题"><a href="#换个思路，简化问题" class="headerlink" title="换个思路，简化问题"></a>换个思路，简化问题</h2><p>以 Vue 为例，服务端渲染包括很多功能，涉及到 Vue 支持的各种 v-* 命令，需要对渲染后的页面中，各种数据状态、事件状态进行复杂的虚拟 DOM 关联处理，所以需要在 Node.js 环境中借助完整的 SSR 模块来渲染。</p><p>但是我们日常真的需要实现这些效果吗？如果切换技术方案的代价这么大，能否折衷一下，找个简单的替代方案？</p><p>结合 mustache.php 的思路，是否可以根据业务中直出的需求，使用一种简单的统一模板，让 Vue 和 php 都能支持渲染？</p><p>动漫业务中，需要直出的情况通常是输出漫画列表，将漫画信息展示出来，便于 SEO 和缓存。</p><p>对于这样的需求，我们可以在切图重构后，微调重构稿代码，将 Vue 挂载到页面内，展示出漫画列表：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"comic-list"</span> <span class="attr">id</span>=<span class="string">"lst_comicList_1"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-cloak</span> <span class="attr">v-for</span>=<span class="string">"(id, item) in list"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">class</span>=<span class="string">"comic-item"</span></span></span><br><span class="line"><span class="tag">         @<span class="attr">click</span>=<span class="string">"clickComicItem"</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">data-id</span>=<span class="string">"c_&#123;&#123;id&#125;&#125;"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"comic-title"</span>&gt;</span>&#123;&#123;item.title&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"comic-desc"</span>&gt;</span>&#123;&#123;item.short_desc != null ? item.short_desc : item.brief_intrd&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">ul</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"> <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">   el: <span class="string">'#lst_comicList_1'</span>,</span></span><br><span class="line"><span class="undefined">   data: &#123;</span></span><br><span class="line"><span class="undefined">     list: &#123;</span></span><br><span class="line"><span class="javascript">       <span class="string">'531490'</span>: &#123;<span class="attr">title</span>: <span class="string">'一人之下'</span>, <span class="attr">short_desc</span>: <span class="string">'身怀异术该何去何从'</span>, <span class="attr">brief_intrd</span>: <span class="string">'随着爷爷尸体被盗，神秘少女冯宝宝的造访，少年张楚岚的平静校园生活被彻底颠覆。急于解开爷爷和自身秘密的张楚岚和没有任何记忆“不死少女”冯宝宝开启了“异人”之旅……'</span>&#125;,</span></span><br><span class="line"><span class="javascript">       <span class="string">'537832'</span>: &#123;<span class="attr">title</span>: <span class="string">'破晓世纪'</span>, <span class="attr">brief_intrd</span>: <span class="string">'一个是重度氪金的“非洲”少年林晓，一个是来历不明的神秘少女伊贝林。阴差阳错下两人签订契约，来到一个人类未曾探索过的宇宙。在这个荒诞而有趣的世界里，林晓是否能够摆脱他的“非洲人”属性，并且开辟属于自己的道路呢……'</span>&#125;</span></span><br><span class="line"><span class="undefined">     &#125;</span></span><br><span class="line"><span class="undefined">   &#125;,</span></span><br><span class="line"><span class="undefined">   method: &#123;</span></span><br><span class="line"><span class="javascript">     <span class="string">'clickComicItem'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">       <span class="keyword">var</span> item = e.currentTarget,</span></span><br><span class="line"><span class="javascript">           comicId = item.getAttribute(<span class="string">'data-id'</span>);</span></span><br><span class="line"><span class="javascript">       alert(<span class="string">'Clicked comic: '</span> + comicId);</span></span><br><span class="line"><span class="undefined">     &#125;</span></span><br><span class="line"><span class="undefined">   &#125;</span></span><br><span class="line"><span class="undefined"> &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而目前使用 php 直出，页面模板代码需要稍作调整：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php $list = array(</span><br><span class="line">         &quot;531490&quot; =&gt; array(&quot;title&quot; =&gt; &quot;一人之下&quot;, &quot;short_desc&quot; =&gt; &quot;身怀异术该何去何从&quot;, &quot;brief_intrd&quot; =&gt; &quot;随着爷爷尸体被盗，神秘少女冯宝宝的造访，少年张楚岚的平静校园生活被彻底颠覆。急于解开爷爷和自身秘密的张楚岚和没有任何记忆“不死少女”冯宝宝开启了“异人”之旅……&quot;),</span><br><span class="line">         &quot;537832&quot; =&gt; array(&quot;title&quot; =&gt; &quot;破晓世纪&quot;, &quot;brief_intrd&quot; =&gt; &quot;一个是重度氪金的“非洲”少年林晓，一个是来历不明的神秘少女伊贝林。阴差阳错下两人签订契约，来到一个人类未曾探索过的宇宙。</span><br><span class="line"> 在这个荒诞而有趣的世界里，林晓是否能够摆脱他的“非洲人”属性，并且开辟属于自己的道路呢……&quot;)</span><br><span class="line">       ); ?&gt;</span><br><span class="line"> &lt;ul class=&quot;comic-list&quot; id=&quot;lst_comicList_1&quot;&gt;</span><br><span class="line">   &lt;?php foreach ($list as $id =&gt; $item) &#123; ?&gt;</span><br><span class="line">   &lt;li class=&quot;comic-item&quot;</span><br><span class="line">       @click=&quot;clickComicItem&quot;</span><br><span class="line">       data-id=&quot;c_&lt;?php echo $id; ?&gt;&quot;&gt;</span><br><span class="line">     &lt;span class=&quot;comic-title&quot;&gt;&lt;?php echo $item[&apos;title&apos;]; ?&gt;&lt;/span&gt;</span><br><span class="line">     &lt;span class=&quot;comic-desc&quot;&gt;&lt;?php echo $item[&apos;short_desc&apos;] != NULL ? $item[&apos;short_desc&apos;] : $item[&apos;brief_intrd&apos;]; ?&gt;&lt;/span&gt;</span><br><span class="line">   &lt;/li&gt;</span><br><span class="line">   &lt;?php &#125;?&gt;</span><br><span class="line"> &lt;/ul&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"> new Vue(&#123;</span><br><span class="line">   el: &apos;#lst_comicList_1&apos;,</span><br><span class="line">   method: &#123;</span><br><span class="line">     &apos;clickComicItem&apos;: function (e) &#123;</span><br><span class="line">       var item = e.currentTarget,</span><br><span class="line">           comicId = item.getAttribute(&apos;data-id&apos;);</span><br><span class="line">       alert(&apos;Clicked comic: &apos; + comicId);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>经过对比后，发现如果稍作限制，只使用 php 与 javascript 通用的语法的话，可以通过简单地替换就将上面的模板转化为下面的效果。</p><p>主要需要处理的地方在于 Vue 模板中的 v-for 和 Mustache 输出标记。</p><p>所以，我们做出以下约束：</p><blockquote><ol><li>只使用 v-for 对列表数据进行渲染，并且必需指定 (<key>, <value>) 两个字段名（暂不支持 v-if、v-else、v-else-if 的转换）。</value></key></li><li>只允许渲染简单的 DOM 结构（用于 SEO 或缓存），不渲染 Vue 组件。</li><li>只处理 &#123;&#123;}} 标记的 Mustache 输出语法，将其简单替换为 php 的 echo 函数，各种 v-bind、v-on、v-model 等指令中参数不会被处理（数据状态不同步）。</li><li>因为是直接替换，php 中不支持的各种 js 运算仍然是不支持的（如：&#123;&#123;item[‘name’] || item[‘nick’]}} 和 &#123;&#123;item[‘name’].join()}}）。</li><li>需要拼接字符串时，请使用 &#123;&#123;id}}_&#123;&#123;item.text}} 的形式，不要使用 &#123;&#123;id + item.text}} 运算（PHP 中不能用 + 运算拼接字符串，会导致转换成整型后做加法）。</li><li>如果不需要对渲染出的 DOM 数据做绑定或更新，只需要做简单的事件控制。可以直接默认保留服务端渲染的 DOM，使用 vue 对象的事件监听器即可。</li><li>对于服务端渲染的 DOM，只能绑定监听器，无法在绑定属性内直接传参。如：</li><li v-on:click="clickItem(item.id)">，需要改为：</li><li v-on:click="clickItem" data-id="&#123;&#123;item.id}}">。事件监听器内读取 e.currentTarget 的 data-id 属性，作为点击判断的依据（不过 Vue 不推荐在 HTML 属性内使用 Mustache，如果有更好的方案欢迎提供思路）。</li><li>如果要通过数据更新 DOM 或者做双向绑定时，需要给服务端渲染的元素增加 clear-before-render 属性。手动输出 json 数据到前端脚本，重新渲染 DOM 替代预渲染的占位 DOM（使用此属性的元素 v-if 会无效化）。</li></ol></blockquote><p>按照以上约束编写的前端模板，即可转换为 php 可用的模板。</p><p>于是根据这个思路，在团队日常使用的前端构建工具中，实现了这类脚本的转换构建任务。（日常使用的前端构建工具：<a href="https://github.com/krimeshu/front-custos-gui" target="_blank" rel="noopener">Front Custos GUI</a>）</p><p>在构建任务的帮助下，页面只需要编写如下的代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php $list = array(</span><br><span class="line">         &quot;531490&quot; =&gt; array(&quot;title&quot; =&gt; &quot;一人之下&quot;, &quot;short_desc&quot; =&gt; &quot;身怀异术该何去何从&quot;, &quot;brief_intrd&quot; =&gt; &quot;随着爷爷尸体被盗，神秘少女冯宝宝的造访，少年张楚岚的平静校园生活被彻底颠覆。急于解开爷爷和自身秘密的张楚岚和没有任何记忆“不死少女”冯宝宝开启了“异人”之旅……&quot;),</span><br><span class="line">         &quot;537832&quot; =&gt; array(&quot;title&quot; =&gt; &quot;破晓世纪&quot;, &quot;brief_intrd&quot; =&gt; &quot;一个是重度氪金的“非洲”少年林晓，一个是来历不明的神秘少女伊贝林。阴差阳错下两人签订契约，来到一个人类未曾探索过的宇宙。</span><br><span class="line"> 在这个荒诞而有趣的世界里，林晓是否能够摆脱他的“非洲人”属性，并且开辟属于自己的道路呢……&quot;)</span><br><span class="line">       ); ?&gt;</span><br><span class="line"> &lt;ul class=&quot;comic-list&quot; id=&quot;lst_comicList_1&quot;&gt;</span><br><span class="line">   &lt;vue-php-ssr-template&gt;</span><br><span class="line">     &lt;li v-cloak clear-before-render</span><br><span class="line">         v-for=&quot;(id, item) in list&quot;</span><br><span class="line">         class=&quot;comic-item&quot;</span><br><span class="line">         @click=&quot;clickComicItem&quot; </span><br><span class="line">         data-id=&quot;c_&#123;&#123;id&#125;&#125;&quot;&gt;</span><br><span class="line">         &lt;span class=&quot;comic-title&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/span&gt;</span><br><span class="line">       &lt;span class=&quot;comic-desc&quot;&gt;&#123;&#123;item.short_desc != null ? item.short_desc : item.brief_intrd&#125;&#125;&lt;/span&gt;</span><br><span class="line">     &lt;/li&gt;</span><br><span class="line">   &lt;/vue-php-ssr-template&gt;</span><br><span class="line"> &lt;/ul&gt; </span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"> new Vue(&#123;</span><br><span class="line">   el: &apos;#lst_comicList_1&apos;,</span><br><span class="line">   data: &#123;</span><br><span class="line">     list: &lt;?php echo json_encode($list); ?&gt;</span><br><span class="line">   &#125;,</span><br><span class="line">   method: &#123;</span><br><span class="line">     &apos;clickComicItem&apos;: function (e) &#123;</span><br><span class="line">       var item = e.currentTarget,</span><br><span class="line">           comicId = item.getAttribute(&apos;data-id&apos;);</span><br><span class="line">       alert(&apos;Clicked comic: &apos; + comicId);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>通过前端构建后，生成的代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php $list = array(</span><br><span class="line">         &quot;531490&quot; =&gt; array(&quot;title&quot; =&gt; &quot;一人之下&quot;, &quot;short_desc&quot; =&gt; &quot;身怀异术该何去何从&quot;, &quot;brief_intrd&quot; =&gt; &quot;随着爷爷尸体被盗，神秘少女冯宝宝的造访，少年张楚岚的平静校园生活被彻底颠覆。急于解开爷爷和自身秘密的张楚岚和没有任何记忆“不死少女”冯宝宝开启了“异人”之旅……&quot;),</span><br><span class="line">         &quot;537832&quot; =&gt; array(&quot;title&quot; =&gt; &quot;破晓世纪&quot;, &quot;brief_intrd&quot; =&gt; &quot;一个是重度氪金的“非洲”少年林晓，一个是来历不明的神秘少女伊贝林。阴差阳错下两人签订契约，来到一个人类未曾探索过的宇宙。</span><br><span class="line"> 在这个荒诞而有趣的世界里，林晓是否能够摆脱他的“非洲人”属性，并且开辟属于自己的道路呢……&quot;)</span><br><span class="line">       ); ?&gt;</span><br><span class="line"> &lt;ul class=&quot;comic-list&quot; id=&quot;lst_comicList_1&quot;&gt;</span><br><span class="line">   &lt;!-- vue-php-ssr-template --&gt;</span><br><span class="line">     &lt;?php foreach ($list as $id =&gt; $item) &#123; ?&gt;</span><br><span class="line">       &lt;li class=&quot;comic-item&quot; </span><br><span class="line">           @click=&quot;clickComicItem&quot; </span><br><span class="line">           data-id=&quot;c_&lt;?php echo $id; ?&gt;&quot;</span><br><span class="line">           v-if=&quot;false&quot;&gt;</span><br><span class="line">         &lt;span class=&quot;comic-title&quot;&gt;&lt;?php echo $item[&apos;title&apos;]; ?&gt;&lt;/span&gt;</span><br><span class="line">       &lt;span class=&quot;comic-desc&quot;&gt;&lt;?php echo $item[&apos;short_desc&apos;] != NULL ? $item[&apos;short_desc&apos;] : $item[&apos;brief_intrd&apos;]; ?&gt;&lt;/span&gt;</span><br><span class="line">       &lt;/li&gt;</span><br><span class="line">     &lt;?php &#125; ?&gt;</span><br><span class="line">   </span><br><span class="line">     &lt;li v-cloak clear-before-render</span><br><span class="line">         v-for=&quot;(id, item) in list&quot;</span><br><span class="line">         class=&quot;comic-item&quot;</span><br><span class="line">         @click=&quot;clickComicItem&quot; </span><br><span class="line">         data-id=&quot;c_&#123;&#123;id&#125;&#125;&quot;&gt;</span><br><span class="line">         &lt;span class=&quot;comic-title&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/span&gt;</span><br><span class="line">         &lt;span class=&quot;comic-desc&quot;&gt;&#123;&#123;item.short_desc != null ? item.short_desc : item.brief_intrd&#125;&#125;&lt;/span&gt;</span><br><span class="line">     &lt;/li&gt;</span><br><span class="line">   &lt;!-- vue-php-ssr-template --&gt;</span><br><span class="line"> &lt;/ul&gt; </span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">   new Vue(&#123;</span><br><span class="line">     el: &apos;#lst_comicList_1&apos;,</span><br><span class="line">     data: &#123;</span><br><span class="line">       list: &lt;?php echo json_encode($list); ?&gt;</span><br><span class="line">     &#125;,</span><br><span class="line">     method: &#123;</span><br><span class="line">       &apos;clickComicItem&apos;: function (e) &#123;</span><br><span class="line">         var item = e.currentTarget,</span><br><span class="line">             comicId = item.getAttribute(&apos;data-id&apos;);</span><br><span class="line">         alert(&apos;Clicked comic: &apos; + comicId);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>由于两端差异，并不能真正实现前后端所有语法、状态的一致，只能说最后勉强达到了我们的目的：只需编写一次模板，php 可以根据转化后的模板在服务端渲染出对应 HTML；前端拿到数据后，可以根据原模板重新渲染或者追加数据。</p><p>这个方案还有不少问题和限制，但是在满足我们日常的需求的前提下，是目前系统变更成本最低的方案。如果大家有更好的思路，欢迎一起交流讨论~</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;测试方案，欢迎提出新的思路，共同探讨！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;/images/vue-php-template-convertor/cover-1.png&quot; title=&quot;cover&quot;&gt;
    
    </summary>
    
      <category term="前端" scheme="http://blog.krimeshu.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vue" scheme="http://blog.krimeshu.com/tags/Vue/"/>
    
      <category term="php" scheme="http://blog.krimeshu.com/tags/php/"/>
    
      <category term="模板" scheme="http://blog.krimeshu.com/tags/%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="直出" scheme="http://blog.krimeshu.com/tags/%E7%9B%B4%E5%87%BA/"/>
    
      <category term="SSR" scheme="http://blog.krimeshu.com/tags/SSR/"/>
    
  </entry>
  
</feed>
